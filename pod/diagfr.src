#if defined(perldiag999)
Ce fichier rassemble tous les diagnostics des versions 5.6.0, 5.6.1
et 5.7.3. Ultérieurement, il y aura également ceux de la version
5.8.0. La séparation entre les diagnostics se fait par des #if defined
dans le style cpp. Cela ne veut pas dire que C<cpp> soit capable de
traiter ce fichier, c'est simplement parce qu'un humain lisant ce
fichier ne sera pas désorienté et comprendra de quoi il s'agit.

Il y aura un jour une version 6 de Perl. Il y aura, peut-être, une
version 7. Mais comme 7 est le nombre de la perfection, il n'y aura
pas besoin d'une version 8 ni, a fortiori, d'une version 9. J'ai tiré
parti de ce fait pour utiliser le numéro de version 999 pour
introduire des commentaires dans le présent fichier.
#endif
#if defined(perldiag560)
=for diagnostics
start description

=head1 Messages de diagnostic

Ces messages sont classés dans un ordre croissant de désespoir :

  (W) Un avertissement (optionnel)
  (D) Une dépréciation (optionnelle)
  (S) Un avertissement sérieux (obligatoire)
  (F) Une erreur fatale (interceptable)
  (P) Une erreur interne (panique) que vous ne devriez jamais rencontrer (interceptable)
  (X) Une erreur extrêmement fatale (non-interceptable)
  (A) Une erreur venue de l'au-delà (non générée par Perl)

La plupart des messages des trois premières classifications ci-dessus
(W, D et S) peuvent être contrôlés en utilisant le pragma C<warnings>
ou les options B<-w> et B<-W>. Si un message peut être contrôlé avec
le pragma C<warnings>, la catégorie correspondante de cet
avertissement est donnée après la lettre de classification ; par
exemple, (W misc) indique un avertissement de type divers.

Les avertissements peuvent être capturés plutôt qu'affichés en
faisant pointer C<$SIG{__WARN__}> sur une référence de routine qui
sera appelée pour chaque message. Vous pouvez également en prendre le
contrôle avant qu'une erreur interceptable « meure » en assignant une
référence de sous-programme à C<$SIG{__DIE__}>, mais si vous
n'appelez pas C<die> à l'intérieur de ce gestionnaire, l'exception
sera toujours présente en revenant. En d'autres termes, il n'est pas
possible de la « défataliser » par ce biais. Vous devez utiliser
C<eval> à cet effet.

Les avertissements par défaut sont toujours activés sauf s'ils sont
explicitement désactivés avec le pragma C<warnings> ou l'option
B<-X>.

Dans les messages suivants, I<%s> représente une chaîne interpolée
qui n'est déterminée qu'au moment de la génération du message. (De
même, I<%d> représente un nombre interpolé --- pensez aux formats de
C<printf>, mais I<%d> signifie ici un nombre dans n'importe quelle
base.) Remarquez que certains messages I<commencent> par I<%s> ---
d'où une certaine difficulté à les classer dans l'ordre alphabétique.
Vous pouvez chercher dans ces messages si celui que vous recherchez
n'apparaît pas à l'endroit attendu.

Si vous êtes persuadé qu'un bogue provient de Perl et non de vous,
essayez de le réduire à un cas de test minimal et faites un rapport
avec le programme I<perlbug> qui est fourni avec Perl.

I<N.d.T.> Les messages sont indiqués ici en anglais tels qu'ils
apparaissent à l'exécution de vos scripts Perl. Toutefois, nous en
donnons ici une traduction pour en faciliter la compréhension.
D'autre part, l'ordre des messages ne correspond pas à celui du livre,
il reprend l'ordre utilisé pour Perl 5.7.3. Donc seuls les caractères
alphabétiques servent pour trier les messages.

=over 4


=for diagnostics
start items

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=for diagnostics
start description

=head1 DESCRIPTION

Ces messages sont classés dans un ordre croissant de désespoir :

  (W) Un avertissement (optionnel)
  (D) Une dépréciation (optionnelle)
  (S) Un avertissement sérieux (obligatoire)
  (F) Une erreur fatale (interceptable)
  (P) Une erreur interne (panique) que vous ne devriez jamais rencontrer (interceptable)
  (X) Une erreur extrêmement fatale (non-interceptable)
  (A) Une erreur venue de l'au-delà (non générée par Perl)

La plupart des messages des trois premières classifications ci-dessus
(W, D et S) peuvent être contrôlés en utilisant le pragma C<warnings>
ou les options B<-w> et B<-W>. Si un message peut être contrôlé avec
le pragma C<warnings>, la catégorie correspondante de cet
avertissement est donnée après la lettre de classification ; par
exemple, (W misc) indique un avertissement de type divers.

Les avertissements peuvent être capturés plutôt qu'affichés en
faisant pointer C<$SIG{__WARN__}> sur une référence de routine qui
sera appelée pour chaque message. Vous pouvez également en prendre le
contrôle avant qu'une erreur interceptable « meure » en assignant une
référence de sous-programme à C<$SIG{__DIE__}>, mais si vous
n'appelez pas C<die> à l'intérieur de ce gestionnaire, l'exception
sera toujours présente en revenant. En d'autres termes, il n'est pas
possible de la « défataliser » par ce biais. Vous devez utiliser
C<eval> à cet effet.

Les avertissements par défaut sont toujours activés sauf s'ils sont
explicitement désactivés avec le pragma C<warnings> ou l'option
B<-X>.

Dans les messages suivants, I<%s> représente une chaîne interpolée
qui n'est déterminée qu'au moment de la génération du message. (De
même, I<%d> représente un nombre interpolé --- pensez aux formats de
C<printf>, mais I<%d> signifie ici un nombre dans n'importe quelle
base.) Remarquez que certains messages I<commencent> par I<%s> ---
d'où une certaine difficulté à les classer dans l'ordre alphabétique.
Vous pouvez chercher dans ces messages si celui que vous recherchez
n'apparaît pas à l'endroit attendu.

Si vous êtes persuadé qu'un bogue provient de Perl et non de vous,
essayez de le réduire à un cas de test minimal et faites un rapport
avec le programme I<perlbug> qui est fourni avec Perl.

I<N.d.T.> Les messages sont indiqués ici en anglais tels qu'ils
apparaissent à l'exécution de vos scripts Perl. Toutefois, nous en
donnons ici une traduction pour en faciliter la compréhension.

=over 4


=for diagnostics
start items

#endif
=item accept() on closed socket %s

(C<accept()> sur une socket fermée I<%s>) (W closed) Vous avez tenté
de faire un C<accept> sur une socket fermée. Peut-être avez-vous
oublié de vérifier la valeur retournée par l'appel de C<socket> ? 
Cf. L<perlfunc/accept>.

=item Allocation too large: %lx

(Allocation trop grande : C<%lx>) (X) Vous ne pouvez allouer plus de
64K sur une machine MS-DOS. 

=item '!' allowed only after types %s

('C<!>' n'est autorisé qu'après les types I<%s>) (F) Le '!' n'est
autorisé dans C<pack> et C<unpack> qu'après certains types. 
Cf. L<perlfunc/pack>.

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

(Appel ambigu résolu avec C<CORE::>I<%s>, qualifiez le ainsi ou
utilisez C<&>) (W ambiguous) Un sous-programme que vous avez déclaré
a le même nom qu'un mot clef de Perl et vous avez utilisé ce nom sans
le qualifier pour que l'on puisse distinguer l'un de l'autre. Perl
décide d'appeler la fonction interne car votre sous-programme n'est
pas importé.

Pour forcer l'interprétation sur l'appel de votre sous-programme,
mettez une esperluette avant le nom ou qualifiez votre sous-programme
avec son nom de paquetage. Ou alors, vous pouvez importer le
sous-programme (ou prétendre le faire avec le pragma C<use subs>).

Pour l'interpréter en silence comme l'opérateur Perl, utilisez le
préfixe C<CORE::> sur cet opérateur (ex. C<CORE::log($x)>)
ou déclarez le sous-programme en tant que méthode objet.
(Cf. L<perlsub/"Subroutine Attributes"> ou L<attributes>).

#if defined(perldiag580) or defined(perldiag573)
=item Ambiguous range in transliteration operator

(Intervalle ambigu dans l'opérateur de translation) (F) Vous avez
écrit quelque chose du genre C<tr/a-z-0//>, ce qui n'a aucun sens.
Pour inclure un caractère C<-> dans une translation, spécifiez-le
en première ou en dernière position. (Dans le temps, C<tr/a-z-0//>
était synonyme de C<tr/a-y//>, ce qui n'est probablement pas
ce que vous vouliez faire).

#endif
=item Ambiguous use of %s resolved as %s

(Utilisation ambiguë de I<%s> résolue avec I<%s>) (W ambiguous | S)
Vous avez exprimé quelque chose qui n'est pas interprété comme vous
le pensiez. Normalement il est assez facile de clarifier la situation
en rajoutant une apostrophe manquante, un opérateur, une paire de
parenthèses ou une déclaration. 

=item '|' and '<' may not both be specified on command line

('C<|>' et 'C<< < >>' ne peuvent pas être spécifiés en même temps sur
la ligne de commande) (F) Il s'agit d'une erreur spécifique à VMS.
Perl effectue ses propres redirections dans la ligne de commande. Il
se trouve que C<STDIN> était un pipe et que vous avez essayé de
rediriger C<STDIN> en utilisant C<< < >>. Un seul flux C<STDIN> par
personne, s'il vous plaît. 

=item '|' and '>' may not both be specified on command line

('C<|>' et 'C<< > >>' ne peuvent pas être spécifiés en même temps sur
la ligne de commande) (F) Il s'agit d'une erreur spécifique à VMS.
Perl effectue ses propres redirections dans la ligne de commande et
pense que vous avez essayé de rediriger C<STDOUT> à la fois dans un
fichier et dans un pipe vers une autre commande. Vous devez choisir
l'un ou l'autre, bien que rien ne vous empêche de rediriger dans un
pipe vers un programme ou un script Perl qui sépare la sortie
standard en deux flux, comme dans :

  open(SORTIE,"> $ARGV[0]")
      or die "Impossible d'écrire dans $ARGV[0] : $!";
  while (<STDIN>) {
      print;
      print SORTIE;
  }
  close SORTIE;

#if defined(perldiag580) or defined(perldiag573)
=item Applying %s to %s will act on scalar(%s)

(Appliquer I<%s> à I<%s> fonctionne avec C<scalar(>I<%s>C<)>) (W misc)
Les opérateurs de recherche de correspondance (C<//>), de substitution
(C<s///>) et de translation (C<tr///>) fonctionnent avec des valeurs
scalaires. Si vous appliquez l'un d'eux à un tableau ou à un hachage,
il convertit ce dernier en une valeur scalaire --- la longueur du
tableau ou les informations sur le peuplement du hachage --- puis
travaille sur la valeur scalaire. Ce n'est probablement pas ce que
vous vouliez faire. Cf. L<perlfunc/grep> et L<perlfunc/map> pour
d'autres possibilités.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Applying %s to %s will act on scalar(%s)

(Appliquer I<%s> à I<%s> fonctionne avec un scalaire (I<%s>)) (W misc)
Les opérateurs de recherche de correspondance (C<//>), de substitution
(C<s///>) et de translation (C<tr///>) fonctionnent avec des valeurs
scalaires. Si vous appliquez l'un d'eux à un tableau ou à un hachage,
il convertit ce dernier en une valeur scalaire --- la longueur du
tableau ou les informations sur le peuplement du hachage --- puis
travaille sur la valeur scalaire. Ce n'est probablement pas ce que
vous vouliez faire. Cf. L<perlfunc/grep> and L<perlfunc/map> for
alternatives.

#endif
=item Args must match #! line

(Les arguments doivent correspondre à la ligne C<#!>) (F) L'émulateur
setuid nécessite que les arguments invoqués par Perl correspondent
avec ceux utilisé sur la ligne C<#!>. Comme certains systèmes
imposent un unique argument sur la ligne C<#!>, essayez de combiner
les options ; par exemple, changez B<-w> B<-U> en B<-wU>. 

=item Arg too short for msgsnd

(Argument trop court pour C<msgsnd>) (F) C<msgsnd> nécessite une
chaîne au moins aussi longue que C<sizeof(long)>. 

=item %s argument is not a HASH or ARRAY element

(L'argument I<%s> n'est un élément ni de HACHAGE, ni de TABLEAU) (F)
L'argument de C<exists> doit être un élément de hachage ou de
tableau, comme :

  $truc{$bidule}
  $ref->{"susie"}[12]

=item %s argument is not a HASH or ARRAY element or slice

(L'argument I<%s> n'est un élément ni de HACHAGE, ni de TABLEAU, ni
une tranche) (F) L'argument de C<delete> doit être soit un élément de
hachage ou de tableau, comme :

  $truc{$bidule}
  $ref->{"susie"}[12]

soit une tranche de hachage ou de tableau, comme :

  @truc[$bidule, $machin, $chouette]
  @{$ref->[12]}{"susie", "queue"}

=item %s argument is not a subroutine name

(L'argument I<%s> n'est pas un nom de sous-programme) (F) L'argument
de C<exists> pour C<exists &sub> doit être un nom de sous-programme
et non un appel de sous-programme. C<exists &sub()> générera cette
erreur. 

=item Argument "%s" isn't numeric%s

(L'argument « I<%s> » n'est pas numérique) (W numeric) La chaîne
indiquée est utilisée comme un argument avec un opérateur qui
s'attend plutôt à une valeur numérique. Si vous êtes chanceux, le
message indique quel opérateur a été si malchanceux. 

=item Array @%s missing the @ in argument %d of %s()

(Le C<@> du tableau C<@>I<%s> est absent dans l'argument I<%d> de I<%s>)
(D deprecated) Les versions vraiment anciennes de Perl permettaient
d'omettre le @ des tableaux à certains endroits. Ceci est maintenant
largement obsolète. 

=item assertion botched: %s

(assertion sabotée : I<%s>) (P) Le paquetage C<malloc> fourni avec
Perl a subi une erreur interne. 

=item Assertion failed: file "%s"

(L'assertion a échoué : fichier « I<%s> ») (P) Une assertion générale
a échoué. Le fichier en question doit être examiné. 

=item Assignment to both a list and a scalar

(Assignement simultané à une liste et à un scalaire) (F) Si vous
affectez à un opérateur conditionnel, les deuxième et troisième
arguments doivent soit être tous les deux des scalaires, soit tous
les deux des listes. Autrement Perl ne connaît pas le contexte à
fournir au côté droit. 

#if defined(perldiag580)
=item A thread exited while %d other threads were still running

(Un thread a effectué un C<exit> alors que I<%d> autres threads
tournaient encore) (W) Lors de l'utilisation d'un Perl avec
threads, un thread (pas forcément le thread principal) a effectué
un C<exit> alors que d'autres threads continuaient à
s'exécuter. D'habitude, il est de bon ton de commencer par
recueillir par C<join> les valeurs de retour de tous les threads,
et ensuite seulement d'arrêter le thread principal avec
C<exit>. Cf. L<threads>.

#endif
#if defined(perldiag580)
=item Attempt to access disallowed key '%s' in a restricted hash

(Tentative d'accéder à la clé « I<%s> » interdite dans un hachage
restreint) (F) Le code en erreur a tenté de lire ou de mettre à
jour une clé qui ne figure pas dans l'ensemble des valeurs de clé
autorisées pour le hachage restreint.

#endif
#if defined(perldiag573)
=item Attempt to access key '%_' in fixed hash

(Tentative d'accéder à la clé '%_' dans un hachage fixe) (F) Un hachage
a été marqué en lecture seule pour obtenir de la sorte un « enregistrement »
avec un ensemble fixé de clés. Le code en cause a essayé de lire ou de mettre
à jour la valeur correspondant à une clé inexistante, ou bien il a tenté
de détruire une clé.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Attempt to bless into a reference

(Tentative de consacrer dans une référence) (F) L'opérateur C<bless> s'attend à ce
que son argument CLASSNAME soit le nom du paquetage dans lequel consacrer 
l'objet. Vous avez peut-être écrit :

    bless $self, $proto;

alors que vous vouliez dire

    bless $self, ref($proto) || $proto;

Si vous voulez réellement consacrer l'objet dans la version
convertie en chaîne de la référence fournie, vous devez la
convertir vous-même, en écrivant par exemple :

    bless $self, "$proto";

#endif
#if defined(perldiag580)
=item Attempt to clear a restricted hash

(Tentative de réinitialisation d'un hachage restreint) (F) Pour l'instant,
il est interdit de nettoyer un hachage restreint, même si c'est pour
lui attribuer ensuite les mêmes clés que précédemment. C'est susceptible
de changer à l'avenir.

#endif
#if defined(perldiag580)
=item Attempt to delete disallowed key '%s' from a restricted hash

(Tentative de destruction d'une clé interdite « I<%s> » dans un
hachage restreint) (F) Le code en erreur a essayé de supprimer
une clé d'un hachage restreint, alors que cette clé ne figure pas
dans l'ensemble des valeurs de clé autorisées pour le hachage
restreint.

#endif
#if defined(perldiag580)
=item Attempt to delete readonly key '%s' from a restricted hash

(Tentative de destruction d'une clé en lecture seule « I<%s> »
dans un hachage restreint) (F) Le code en erreur a essayé de
supprimer une clé d'un hachage restreint, alors que cette clé
était déclarée en lecture seule.

#endif
=item Attempt to free non-arena SV: 0x%lx

(Tentative de libérer un SV hors d'une zone : C<0x>I<%lx>) (P internal)
Tous les objets SV sont supposés être alloués dans une zone qui sera
nettoyée à la sortie du script. Un SV a été découvert en dehors d'une
de ces zones. 

=item Attempt to free nonexistent shared string

(Tentative de libérer une chaîne partagée inexistante) (P internal)
Perl maintient une table interne qui compte les références de chaînes
pour optimiser le stockage et l'accès au clefs de hachages et aux
autres chaînes. Ce message indique que quelqu'un a essayé de
décrémenter le compteur de références d'une chaîne que l'on ne peut
plus trouver dans la table. 

=item Attempt to free temp prematurely

(Tentative prématurée de libérer une valeur temporaire) (W debugging)
Les valeurs à l'agonie (I<mortalized>) sont supposées être libérées
par la routine interne C<free_tmps>. Ce message indique que quelque
chose d'autre est en train de libérer le SV avant que la routine
C<free_tmps> ait une chance de le faire, ce qui signifie que la
routine C<free_tmps> libérera un scalaire non référencé au moment où
elle tentera de le faire. 

=item Attempt to free unreferenced glob pointers

(Tentative de libérer des pointers de glob non référencés) (P
internal) Le compteur de références a été endommagé en ce qui
concerne les alias de symboles. 

#if defined(perldiag561) or defined(perldiag560)
=item Attempt to free unreferenced scalar

(Tentative de libérer un scalaire non référencé) (W internal) Perl
allait décrémenter un compteur de références d'un scalaire pour voir
s'il arrivait à 0 et a découvert qu'il était déjà arrivé à 0
auparavant et qu'il se pourrait qu'il ait été libéré et, en fait,
qu'il a probablement été libéré. Cela peut indiquer que
C<SvREFCNT_dec> a été appelé trop de fois ou que C<SvREFCNT_inc> n'a
pas été appelé assez de fois ou encore que le SV a été achevé
(I<mortalized>) alors qu'il n'aurait pas dû l'être ou enfin que la
mémoire a été corrompue. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Attempt to free unreferenced scalar

(Tentative de libérer un scalaire non référencé) (W internal) Perl
allait décrémenter un compteur de références d'un scalaire pour voir
s'il arrivait à 0 et a découvert qu'il était déjà arrivé à 0
auparavant et qu'il se pourrait qu'il ait été libéré et, en fait,
qu'il a probablement été libéré. Cela peut indiquer que
C<SvREFCNT_dec> a été appelé trop souvent ou que C<SvREFCNT_inc> n'a
pas été appelé assez souvent ou encore que le SV a été achevé
(I<mortalized>) alors qu'il n'aurait pas dû l'être ou enfin que la
mémoire a été corrompue. 

#endif
=item Attempt to join self

(Tentative de se rejoindre soi-même) (F) Vous avez essayer de
rejoindre avec C<join> une tâche (I<thread>) à partir d'elle-même, ce
qui est une opération impossible. Vous pourriez rejoindre la mauvaise
tâche ou avoir besoin de déplacer le C<join> vers une autre tâche. 

=item Attempt to pack pointer to temporary value

(Tentative d'empaqueter un pointeur vers une valeur temporaire) (W
pack) Vous avez essayé de passer une valeur temporaire (comme le
résultat d'une fonction ou une expression calculée) au canevas C<p>
de C<pack>. Cela signifie que le résultat contient un pointeur vers
un endroit qui pourrait devenir invalide à tout moment, même avant la
fin de l'instruction en cours. Utilisez des valeurs littérales ou
globales comme arguments du canevas C<p> de C<pack> pour éviter cet
avertissement. 

=item Attempt to use reference as lvalue in substr

(Tentative d'utiliser une référence en tant que lvalue dans
C<substr>) (W substr) Vous avez soumis une référence utilisée en tant
que lvalue comme premier argument de C<substr>, ce qui est vraiment
étrange. Peut-être avez-vous oublié de la déréférencer en premier
lieu. Cf. L<perlfunc/substr>.

#if defined(perldiag561) or defined(perldiag560)
=item Bad arg length for %s, is %d, should be %d

(Mauvaise longueur d'argument pour I<%s>, vaut I<%d>, devrait valoir
I<%d>) (F) Vous avez passé un tampon de taille incorrecte à
C<msgctl>, C<semctl> ou C<shmctl>. En C, les tailles correctes sont
respectivement C<sizeof(struct msqid_ds *)>, C<sizeof(struct semid_ds
*)> et C<sizeof(struct shmid_ds *)>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Bad arg length for %s, is %d, should be %s

(Mauvaise longueur d'argument pour I<%s>, vaut I<%d>, devrait valoir
I<%s>) (F) Vous avez passé un tampon de taille incorrecte à
C<msgctl>, C<semctl> ou C<shmctl>. En C, les tailles correctes sont
respectivement C<sizeof(struct msqid_ds *)>, C<sizeof(struct semid_ds
*)> et C<sizeof(struct shmid_ds *)>. 

#endif
=item Bad evalled substitution pattern

(Mauvaise évaluation du motif de substitution) (F) Vous avez utilisé
l'option C</e> pour évaluer l'expression de remplacement pour une
substitution mais Perl a trouvé une erreur de syntaxe dans le code à
évaluer, très certainement une parenthèse fermante inattendue. 

=item Bad filehandle: %s

(Mauvais handle de fichier : I<%s>) (F) Un symbole a été passé à
quelque chose qui s'attendait à un handle de fichier mais le symbole
n'a aucun handle de fichier qui lui soit associé. Peut-être avez-vous
oublié de faire un C<open> ou dans vous l'avez fait dans un autre
paquetage. 

#if defined(perldiag560)
=item Bad free() ignored

(Mauvais C<free()> ignoré) (S malloc) Une routine interne a appelé
C<free> sur quelque chose qui n'avait jamais été alloué avec
C<malloc> dans un premier temps. Ce message est obligatoire mais peut
être désactivé en positionnant la variable d'environnement
C<PERL_BADFREE> à 1.

Ce message peut être assez fréquent avec C<DB_file> sur les systèmes
avec une édition de liens dynamiques en « dur », comme AIX et OS/2.
C'est un bug de Berkeley DB.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Bad free() ignored

(Mauvais C<free()> ignoré) (S malloc) Une routine interne a appelé
C<free> sur quelque chose qui n'avait jamais été alloué avec
C<malloc> dans un premier temps. Ce message est obligatoire mais peut
être désactivé en positionnant la variable d'environnement
C<PERL_BADFREE> à 0.

Ce message peut être assez fréquent avec C<DB_file> sur les systèmes
avec une édition de liens dynamiques « en dur », comme AIX et OS/2.
C'est un bug de Berkeley DB, que l'on ne remarque pas si C<DB> utilise
un C<malloc> compréhensif.

#endif
=item Bad hash

(Mauvais hachage) (P) Une des routines internes concernant un hachage
a passé un pointeur HV nul. 

=item Bad index while coercing array into hash

(Mauvais indice lors de la transformation d'un tableau en hachage)
(F) La recherche dans le hachage, 0ème élément d'un pseudo-hachage, a
découvert un indice illégal. La valeur des indices doit être
supérieure ou égale à 1. 

=item Badly placed ()'s

(Parenthèses mal disposées) (A) Vous avez lancé accidentellement
votre script avec I<csh> au lieu de Perl. Vérifiez la ligne avec
C<#!> ou lancez vous-même votre script dans Perl avec I<perl
nom_script>. 

=item Bad name after %s::

(Mauvais nom après I<%s>C<::>) (F) Vous avez commencé un nom de
symbole en utilisant un préfixe de paquetage puis vous n'avez pas
fini le symbole. En particulier, vous ne pouvez pas faire
d'interpolation en dehors des guillemets, ainsi :

  $var = 'ma_var';
  $sym = mon_paquetage::$var;

n'est pas identique à :

  $var = 'ma_var';
  $sym = "mon_paquetage::$var";

=item Bad realloc() ignored

(Mauvais C<realloc()> ignoré) (S malloc) Une routine interne a appelé
C<realloc> sur quelque chose qui n'avait jamais été alloué avec
C<malloc> dans un premier temps. Ce message est obligatoire mais peut
être désactivé en positionnant la variable d'environnement
C<PERL_BADFREE> à 1. 

=item Bad symbol for array

(Mauvais symbole pour un tableau) (P) Une requête interne a demandé à
ajouter une entrée de tableau à quelque chose qui n'est pas une
entrée dans la table des symboles. 

=item Bad symbol for filehandle

(Mauvais symbole pour un handle de fichier) (P) Une requête interne a
demandé à ajouter une entrée de handle de fichier à quelque chose qui
n'est pas une entrée dans la table des symboles. 

=item Bad symbol for hash

(Mauvais symbole pour un hachage) (P) Une requête interne a demandé à
ajouter une entrée de hachage à quelque chose qui n'est pas une
entrée dans la table des symboles. 

=item Bareword found in conditional

(Mot simple détecté dans une condition) (W bareword) Le compilateur a
trouvé un mot simple là où il attendait une condition, ce qui indique
souvent qu'un C<||> ou un C<&&> a été analysé comme faisant partie du
dernier argument de la construction précédente, par exemple :

  open FOO || die;

Cela peut également indiqué une constante mal orthographiée qui a été
interprétée en tant que mot simple :

  use constant TYPO => 1;
  if (TYOP) { print "truc" }

Le pragma C<strict> est très utile pour éviter de telles erreurs.

=item Bareword "%s" not allowed while "strict subs" in use

(Mot simple « I<%s> » interdit lorsque « C<strict subs> » est activé)
(F) Avec « C<strict subs> » activé, un mot simple n'est autorisé que
comme identificateur de sous-programme, entre accolades ou à la
gauche du symbole C<< => >>. Peut-être devriez-vous déclarer au
préalable votre sous-programme ? 

=item Bareword "%s" refers to nonexistent package

(Le mot simple « I<%s> » se réfère à un paquetage inexistant) (W
bareword) Vous avez utilisé un mot simple qualifié de la forme
C<Truc::> mais le compilateur n'a pas vu d'autre utilisation de
cet espace de noms avant cet endroit. Peut-être devriez-vous déclarer
au préalable votre paquetage ? 

=item BEGIN failed--compilation aborted

(Échec de C<BEGIN> --- compilation abandonnée)(F) Une exception non
interceptable a été levée pendant l'exécution d'un sous-programme
C<BEGIN>. La compilation s'arrête immédiatement et l'on quitte
l'interpréteur. 

=item BEGIN not safe after errors--compilation aborted

(C<BEGIN> non sécurisé après des erreurs --- compilation abandonnée)
(F) Perl a trouvé un sous-programme C<BEGIN> (ou une directive
C<use>, ce qui implique un C<BEGIN>) après qu'une ou plusieurs
erreurs de compilation sont déjà survenues. Comme l'environnement du
C<BEGIN> ne peut être garanti (à cause des erreurs) et comme le code
qui suit est susceptible de dépendre de son bon fonctionnement, Perl
rend son tablier.

=item \1 better written as $1

(Il est préférable d'écrire C<$1> plutôt que C<\1>) (W syntax) À
l'extérieur des motifs, les références arrières (I<backreferences>)
existent en tant que variables. L'utilisation d'antislashs du côté
droit d'une substitution était autorisée pour nos grands-pères, mais
stylistiquement, il mieux vaut adopter la forme des variables
attendue par les autres programmeurs Perl. De plus, cela fonctionne
mieux s'il y a plus de neuf références arrières. 

=item Binary number > 0b11111111111111111111111111111111 non-portable

(Nombre binaire > C<0b11111111111111111111111111111111>, non
portable) (W portable) Le nombre binaire que vous avez spécifié est
plus grand que C<2**31-1> (4 294 967 295) et n'est donc pas portable
entre les systèmes. 
Cf. L<perlport> pour plus de renseignements sur les questions de portabilité.

=item bind() on closed socket %s

(C<bind> sur une socket fermée I<%s>) (W closed) Vous avez essayé de
faire un C<bind> sur une socket fermée. Peut-être avez-vous oublié de
vérifier la valeur renvoyée par l'appel de C<socket> ? 
Cf. L<perlfunc/bind>.

#if defined(perldiag580) or defined(perldiag573)
=item binmode() on closed filehandle %s

(C<binmode()> sur le handle de fichier fermé %s) (W unopened) Vous
avez tenté d'effectuer un C<binmode()> sur un handle de fichier qui
n'a jamais été ouvert. Vérifiez la logique de déroulement de votre
programme et le nombre d'arguments.

#endif
=item Bit vector size > 32 non-portable

(Taille de vecteur de bits > 32, non portable) (W portable)
L'utilisation de tailles de vecteurs de bits supérieures à 32 n'est
pas portable. 

=item Bizarre copy of %s in %s

(Copie étrange de I<%s> dans I<%s>) (P) Perl a détecté une tentative
de copie d'une valeur interne qui n'est pas copiable. 

=item B<-P> not allowed for setuid/setgid script

(C<-P> n'est pas autorisé pour un script setuid/setgid) (F) Le
préprocesseur C a voulu ouvrir le script en l'appelant par son nom,
ce qui entraîne une situation de concurrence (I<N.d.T.> : I<race
condition>) qui casse la sécurité. 

=item Buffer overflow in prime_env_iter: %s

(Dépassement du tampon dans C<prime_env_iter> : I<%s>) (W internal)
Il s'agit d'un avertissement spécifique à VMS. Pendant que Perl se
préparait à parcourir C<%ENV>, il a rencontré un nom logique ou une
définition de symbole qui était trop long, il l'a donc tronqué vers
la chaîne indiquée. 

=item Callback called exit

(La fonction de rappel a appelé C<exit>) (F) Un sous-programme
invoqué depuis un paquetage externe via C<call_sv> s'est terminée en
appelant C<exit>. 

=item %s() called too early to check prototype

(I<%s> appelée trop tôt pour vérifier le prototype) (W prototype) Vous
avez appelé une fonction possédant un prototype avant que l'analyseur
syntaxique ne voie sa déclaration ou sa définition et Perl ne peut pas
vérifier si l'appel se conforme au prototype. Pour obtenir une
vérification correcte du prototype, vous devez soit ajouter une
déclaration du prototype pour le sous-programme en question plus haut
dans le code, soit déplacer la définition du sous-programme avant
l'appel. Ou alors, si vous êtes certains d'appeler la fonction
correctement, vous pouvez mettre une esperluette devant le nom pour
éviter l'avertissement. Cf. L<perlsub>.

=item / cannot take a count

(C</> ne peut pas être lié à un compteur) (F) Vous aviez un canevas
pour C<unpack> indiquant une chaîne d'une longueur sujette à un
compteur mais vous avez également spécifié une taille explicite pour
cette chaîne. Cf. L<perlfunc/pack>.

=item Can't bless non-reference value

(Impossible de consacrer avec C<bless> une valeur qui ne soit pas une
référence) (F) Seules les références en dur peuvent être consacrées
avec C<bless>. C'est de cette manière que Perl « applique »
l'encapsulation des objets. 

#if defined(perldiag560)
=item Can't break at that line

(Impossible de s'arrêter à cette ligne) (S internal) Il s'agit d'un
message d'erreur qui n'est affiché que lorsque le programme s'exécute
avec le débogueur, indiquant que le numéro de ligne spécifié n'est
pas l'emplacement d'une instruction à laquelle on peut s'arrêter. 

#endif
=item Can't call method "%s" in empty package "%s"

(Impossible d'appeler la méthode « I<%s> » dans le paquetage vide 
« I<%s> ») (F) Vous avez appelé une méthode correctement et vous avez
indiqué correctement le paquetage pris en tant que classe, mais ce
paquetage n'a I<rien> de défini et n'a pas de méthodes.
Cf. L<perlobj>.

=item Can't call method "%s" on an undefined value

(Impossible d'appeler la méthode « I<%s> » sur une valeur indéfinie)
(F) Vous avez utilisé la syntaxe d'un appel de méthode, mais la place
réservée à la référence d'objet ou au nom du paquetage contient une
une valeur indéfinie. Quelque chose comme ceci reproduira l'erreur :

  $MAUVAISE_REF = undef;
  traite $MAUVAISE_REF 1,2,3;
  $MAUVAISE_REF->traite(1,2,3);

=item Can't call method "%s" on unblessed reference

(Impossible d'appeler la méthode « I<%s> » sur une référence non
consacrée avec C<bless>) (F) Un appel de méthode doit savoir depuis
quel paquetage elle est supposé être lancée. Il trouve habituellement
ceci dans la référence de l'objet que vous soumettez mais vous n'avez
pas fourni de référence d'objet dans ce cas. Une référence n'est pas
une référence d'objet jusqu'à ce qu'elle ait été consacrée (avec
C<bless>). Cf. L<perlobj>.

=item Can't call method "%s" without a package or object reference

(Impossible d'appeler la méthode « I<%s> » dans un paquetage ou une
référence d'objet) (F) Vous avez utilisé la syntaxe d'un appel de
méthode mais la place réservée à la référence d'objet ou au nom du
paquetage contient une expression qui retourne une valeur définie qui
n'est ni une référence d'objet ni un nom de paquetage. Quelque chose
comme ceci reproduira l'erreur : 

  $MAUVAISE_REF = 42;
  traite $MAUVAISE_REF 1,2,3;
  $MAUVAISE_REF->traite(1,2,3);

=item Can't chdir to %s

(C<chdir> impossible vers I<%s>) (F) Vous avez appelé I<perl
-x/truc/bidule>, mais I</truc/bidule> n'est pas un répertoire dans
lequel vous pouvez rentrer avec C<chdir>, probablement parce qu'il
n'existe pas. 

=item Can't check filesystem of script "%s" for nosuid

(Impossible de vérifier le C<nosuid> pour le système de fichier du
script « I<%s> ») (P) Pour une raison ou pour une autre, vous ne
pouvez pas vérifier le C<nosuid> pour le système de fichier du
script. 

=item Can't coerce array into hash

(Impossible de convertir un tableau vers un hachage) (F) Vous avez
utilisé un tableau là où un hachage était attendu, mais le tableau
n'a pas d'informations sur la manière de passer des clés aux indices
de tableau. Vous ne pouvez faire cela qu'avec les tableaux qui ont
une référence de hachage à l'indice 0. 

=item Can't coerce %s to integer in %s

(Impossible de convertir I<%s> vers un entier dans I<%s>) (F) On ne
peut pas forcer certains types de SV, en particulier les entrées de la
table des symboles (typeglobs) à cesser d'être ce qu'ils sont. Donc
vous ne pouvez pas faire des choses telles que :

  *truc += 1;

Vous I<pouvez> écrire :

  $truc = *truc;
  $truc += 1;

mais alors C<$truc> ne contient plus de glob.

=item Can't coerce %s to number in %s

(Impossible de convertir I<%s> vers un nombre dans I<%s>) (F) On ne
peut pas forcer certains types de SV, en particulier les entrées de
la table des symboles (typeglobs) à cesser d'être ce qu'ils sont. 

=item Can't coerce %s to string in %s

(Impossible de convertir I<%s> vers une chaîne dans I<%s>) (F) On ne
peut pas forcer certain types de SVs, en particulier les entrées de
la table des symboles (typeglobs) à cesser d'être ce qu'ils sont. 

=item Can't create pipe mailbox

(Impossible de créer un pipe de boîte aux lettres) (P) Il s'agit
d'une erreur spécifique à VMS. Le processus souffre de quotas
dépassés ou d'autres problèmes de plomberie. 

#if defined(perldiag561) or defined(perldiag560)
=item Can't declare class for non-scalar %s in "%s"

(Impossible de déclarer une classe pour le non-scalaire I<%s> dans 
« I<%s> ») (S) Actuellement, seules les variables scalaires peuvent
être déclarée avec un qualificateur de classe spécifique dans une
déclaration C<my> ou C<our>. Les sémantiques peuvent être étendues à
d'autres types de variables à l'avenir. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Can't declare class for non-scalar %s in "%s"

(Impossible de déclarer une classe pour le non-scalaire I<%s> dans 
« I<%s> ») (F) Actuellement, seules les variables scalaires peuvent
être déclarée avec un qualificateur de classe spécifique dans une
déclaration C<my> ou C<our>. Les sémantiques peuvent être étendues à
d'autres types de variables à l'avenir. 

#endif
=item Can't declare %s in "%s"

(Impossible de déclarer I<%s> dans « I<%s> ») (F) Seuls les
scalaires, les tableaux et les hachages peuvent être déclarés comme
variables C<my> ou C<our>. Ils doivent avoir un identificateur
ordinaire comme nom. 

=item Can't do inplace edit: %s is not a regular file

(Impossible d'éditer sur place : I<%s> n'est pas un fichier
ordinaire) (S inplace) Vous avez essayé d'utiliser l'option B<-i> sur
un fichier spécial, comme un fichier dans I</dev> ou une FIFO. Le
fichier a été ignoré. 

=item Can't do inplace edit on %s: %s

(Impossible d'éditer sur place I<%s>) (S inplace) La création du
nouveau fichier a échoué à cause de la raison indiquée. 

=item Can't do inplace edit without backup

(Impossible d'éditer sur place sans copie de sauvegarde) (F) Vous
êtes sur un système comme MS-DOS qui s'embrouille si vous essayez de
lire un fichier supprimé (mais toujours ouvert). Vous devez écrire
I<-i.bak>, ou quelque chose comme ça. 

=item Can't do inplace edit: %s would not be unique

(Impossible d'éditer sur place : I<%s> ne serait pas unique) (S
inplace) Votre système de fichier ne supporte pas les noms de
fichiers plus longs que 14 caractères et Perl n'a pas pu créer un nom
de fichier unique durant l'édition sur place avec l'option B<-i>. Ce
fichier a été ignoré. 

#if defined(perldiag560)
=item Can't do {n,m} with n > m

(Impossible de faire C<{n,m}> avec C<n> > C<m>) (F) Les minima
doivent être inférieurs ou égaux aux maxima. Si vous voulez vraiment
que votre expression régulière corresponde 0 fois, faites juste
C<{0}>. 

#endif
#if defined(perldiag561)
=item Can't do {n,m} with n > m before << HERE in regex m/%s/

(Impossible de faire C<{n,m}> avec C<n> > C<m>) (F) Les minima
doivent être inférieurs ou égaux aux maxima. Si vous voulez vraiment
que votre expression régulière corresponde 0 fois, faites juste
C<{0}>. Le marqueur « HERE » montre l'endroit dans l'expression 
régulière où le problème a été constaté. Cf. L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Can't do {n,m} with n > m in regex; marked by <-- HERE in m/%s/

(Impossible de faire C<{n,m}> avec C<n> > C<m>) (F) Les minima doivent
être inférieurs ou égaux aux maxima. Si vous voulez vraiment que votre
expression régulière corresponde 0 fois, faites juste C<{0}>. La
mention « <-- HERE » indique l'endroit où le problème a été constaté.
Cf L<perlre>.

#endif
=item Can't do setegid!

(C<setegid> impossible !) (P) L'appel à C<setegid> a échoué pour une
raison ou pour une autre dans l'émulateur setuid de I<suidperl>. 

=item Can't do seteuid!

(C<seteuid> impossible !) (P) L'émulateur setuid de I<suidperl> a
échoué pour une raison ou pour une autre. 

=item Can't do setuid

(C<setuid> impossible) (F) Cela veut généralement dire que le I<perl>
ordinaire a essayé de faire C<exec> I<suidperl> pour émuler le
setuid, mais n'a pas pu faire le C<exec>. Il cherche un nom de la
forme I<sperl5.000> dans le même répertoire que celui où réside
l'exécutable perl sous le nom I<perl5.000>, généralement
I</usr/local/bin> sur les machines Unix. Si le fichier s'y trouve,
vérifiez les permissions d'exécution. S'il n'est pas là, demandez à
votre administrateur système pourquoi. 

=item Can't do waitpid with flags

(C<waitpid> impossible avec les drapeaux) (F) Cette machine n'a pas
ni C<waitpid> ni C<wait4>, ainsi seul C<waitpid> sans aucun drapeau
est émulé. 

=item Can't emulate -%s on #! line

(Impossible d'émuler -I<%s> sur la ligne C<#!>) (F) La ligne C<#!>
spécifie une option qui n'a pas de sens à cet endroit. Par exemple,
il serait un peu idiot de mettre l'option B<-x> sur cette ligne
C<#!>. 

=item Can't exec "%s": %s

(C<exec> de « I<%s> » impossible : I<%s>) (W exec) L'appel à
C<system>, C<exec>, ou C<open> sur un pipe n'a pu s'exécuter pour la
raison indiquée. Les raisons habituelles incluent de mauvaises
permissions sur le fichier, que le fichier n'a pu être trouvé dans
C<$ENV{PATH}>, que l'exécutable en question a été compilé pour une
autre architecture ou que la ligne C<#!> pointe vers un interpréteur
qui ne peux pas être lancé pour des raisons similaires. (Ou peut-être
votre système ne supporte pas du tout C<#!>). 

=item Can't exec %s

(C<exec> I<%s> impossible) (F) Perl a essayé d'exécuter le programme
indiqué pour vous car c'est ce qui est spécifié sur la ligne C<#!>.
Si ce n'est pas ce que vous vouliez, vous devrez mentionner C<perl>
quelque part sur la ligne C<#!>. 

=item Can't execute %s

(Impossible d'exécuter I<%s>) (F) Vous avez utilisé l'option B<-S>,
mais les copies du script à exécuter trouvées dans le C<PATH> n'ont
pas les bonnes permissions. 

=item Can't find an opnumber for "%s"

(Impossible de trouver un numéro d'opération pour « I<%s> ») (F) Une
chaîne de la forme C<CORE::>I<mot> a été donnée à C<prototype>
mais il n'existe pas de fonction interne nommée I<mot>. 

#if defined(perldiag580) or defined(perldiag573)
=item Can't find %s character property "%s"

(Impossible de trouver la propriété de caractères « %s ») (F)
Vous avez utilisé C<\p{}> ou C<\P{}>, mais aucune propriété de ce nom 
n'a pu être trouvée. Peut-être avez-vous fait une faute de frappe dans
le nom de la propriété (souvenez-vous qu'un nom de propriété est constitué
uniquement de caractères alphanumériques), ou peut-être avez-vous
omis le préfixe C<Is> ou C<In> ?

#endif
=item Can't find label %s

(Impossible de trouver l'étiquette I<%s>) (F) Vous avez dit par un
C<goto> d'aller à une étiquette qui n'est mentionnée à aucun endroit
où il nous est possible d'aller. Cf. L<perlfunc/goto>.

=item Can't find %s on PATH

(Impossible de trouver I<%s> dans le C<PATH>) (F) Vous utilisez
l'option B<-S>, mais le script à exécuter ne peut être trouvé dans le
C<PATH>. 

=item Can't find %s on PATH, '.' not in PATH

(Impossible de trouver I<%s> dans le C<PATH>, « C<.> » n'est pas dans
le C<PATH>) (F) Vous avez utilisé l'option B<-S>, mais le script à
exécuter ne peut être trouvé dans le C<PATH> ou tout au moins pas avec
des permissions correctes. Le script existe dans le répertoire
courant, mais le C<PATH> l'empêche de se lancer. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Can't find %s property definition %s

(Définition de la propriété I<%s> introuvable) (F) Vous avez peut-être
tenté d'utiliser C<\p>, qui représente une propriété Unicode. Par exemple,
C<\p{Lu}> représente toutes les lettres majuscules. Protégez la chaîne
C<\p>, soit par C<\\p> (ce qui ne protège que C<\p>), soit par C<\Q\p>
(ce qui protège le reste de la chaîne, jusqu'au prochain C<\E> le cas
échéant).

#endif
#if defined(perldiag580)
=item Can't find %s property definition %s

(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

#endif
#if defined(perldiag573) or defined(perldiag561) or defined(perldiag560)
=item Can't find string terminator %s anywhere before EOF

(Impossible de trouver la fin de la chaîne I<%s> quelque part avant
C<EOF>) (F) Les chaînes de caractères en Perl peuvent s'étirer sur
plusieurs lignes. Ce message signifie que vous avez oublié le
délimitateur fermant. Comme les parenthèses protégées par des
apostrophes comptent pour un niveau, il manque la parenthèse finale
dans l'exemple suivant :

  print q(Le caractère '(' commence une nouvelle citation.);

Si vous obtenez cette erreur depuis un document « ici-même »
(I<N.d.T.> : I<here document>), vous devez avoir mis des espaces
blancs invisibles avant ou après la marque de fermeture. Un bon
éditeur pour les programmeurs devrait pouvoir vous aider à trouver
ces caractères.

#endif
=item Can't fork

(C<fork> impossible)(F) Une erreur fatale est survenue en essayant de
faire un C<fork>. 

=item Can't get filespec - stale stat buffer?

(Impossible d'obtenir la spécification du fichier - tampon C<stat>
périmé ?) (S) Il s'agit d'un avertissement spécifique à VMS. Ceci
arrive à cause des différences entre les contrôles d'accès sous VMS
et sous le modèle Unix qui est celui que Perl présuppose. Sous VMS,
les contrôles d'accès sont faits par le nom de fichier, plutôt que par
les bits du tampon de C<stat>, ce qui fait que les ACL et les autres
protections peuvent être pris en compte. Malheureusement, Perl
présuppose que le tampon de C<stat> contient toutes les informations
nécessaires et le fournit, à la place de la spécification du fichier,
à la fonction de contrôle d'accès. Il va essayer d'obtenir les
spécifications du fichier en utilisant le nom du périphérique et le
FID présents dans le tampon de C<stat>, mais si vous avez fait
ensuite un appel à la fonction C<stat> de CRTL, cela ne fonctionnera
pas car le nom du périphérique est écrasé à chaque appel. Si cet
avertissement apparaît, la recherche de nom a échoué et la fonction
de contrôle d'accès a rendu la main en retournant une valeur fausse,
histoire d'être un peu conservateur. (Remarque : la fonction de
contrôle d'accès connaît l'opérateur C<stat> de Perl et les tests de
fichiers, vous ne devriez donc jamais voir cet avertissement en
réponse à une commande Perl ; il ne se produit que si du code interne
prend les tampons de C<stat> à la légère.) 

=item Can't get pipe mailbox device name

(Impossible d'obtenir le nom de périphérique d'un pipe de boîte aux
lettres) (P) Il s'agit d'une erreur spécifique à VMS. Après avoir
créé une boîte aux lettres se comportant comme un pipe, Perl ne peut
obtenir son nom pour un usage ultérieur. 

=item Can't get SYSGEN parameter value for MAXBUF

(Impossible d'obtenir la valeur du paramètre C<SYSGEN> pour
C<MAXBUF>) (P) Il s'agit d'une erreur spécifique à VMS. Perl a
demande à C<$GETSYI> quelle taille vous voulez pour vos tampons de
boîtes aux lettres et il n'a pas obtenu de réponse. 

=item Can't "goto" into the middle of a foreach loop

(« C<goto> » impossible vers le milieu d'une boucle C<foreach>) (F)
Une instruction C<goto> a été exécutée pour sauter au milieu d'une
boucle C<foreach>. Vous ne pouvez y aller depuis cet endroit. 
Cf. L<perlfunc/goto>.

=item Can't "goto" out of a pseudo block

(« C<goto> » impossible vers l'extérieur d'un pseudo-bloc) (F) Une
instruction C<goto> a été exécutée pour quitter ce qui semblerait
être un bloc, excepté que ce n'est pas un bloc correct. Ceci se
produit habituellement si vous essayez de sauter hors d'un bloc sort
ou d'un sous-programme, ce qui n'a pas de sens. 
Cf. L<perlfunc/goto>.

=item Can't goto subroutine from an eval-string

(C<goto> vers un sous-programme impossible depuis une chaîne C<eval>)
(F) L'appel C<goto> I<SOUS_PROGRAMME> ne peut être utilisé pour
sortir d'une chaîne C<eval>. (Vous pouvez l'utiliser pour sortir d'un
C<eval> I<BLOC> mais ce n'est probablement pas ce que vous voulez.) 

=item Can't goto subroutine outside a subroutine

(C<goto> vers un sous-programme impossible à l'extérieur d'un
sous-programme) (F) L'appel hautement magique C<goto>
I<SOUS_PROGRAMME> ne peut que remplacer l'appel d'une fonction par une
autre. Il ne peut en fabriquer une brute de fonderie. En général, vous
ne devriez de toute façon l'appeler que depuis une fonction
d'C<AUTOLOAD>. Cf. L<perlfunc/goto>.

=item Can't ignore signal CHLD, forcing to default

(Impossible d'ignorer le signal C<CHLD>, la valeur par défaut est
forcée) (W signal) Perl a détecté qu'il avait été lancé avec le
signal C<SIGCHLD> (quelquefois appelé C<SIGCLD>) désactivé. Comme la
désactivation de ce signal va interférer avec une détermination
correcte du statut de sortie des processus fils, Perl a remis le
signal à sa valeur par défaut. Cette situation indique généralement
que le programme père sous lequel Perl pourrait tourner (exemple :
I<cron>) est très peu précautionneux. 

=item Can't "last" outside a loop block

(« C<last> » impossible vers l'extérieur d'un bloc de boucle) (F) Une
instruction C<last> a été exécutée pour sortir du bloc courant,
excepté ce léger problème qu'il n'existe pas de bloc courant.
Remarquez que les blocs C<if> ou C<else> ne comptent pas comme des
blocs de boucle, tout comme tout comme les blocs passés à C<sort>,
C<map> ou C<grep>. Vous pouvez habituellement doubler les accolades
pour obtenir le même effet, car les accolades intérieures seront
considérées comme un bloc qui boucle une seule fois.
Cf. L<perlfunc/last>.

=item Can't localize lexical variable %s

(Impossible de rendre locale la variable I<%s>) (F) Vous avez utilisé
C<local> sur une variable qui a déjà été déclarée auparavant comme
une variable lexicale à l'aide de C<my>. Ceci n'est pas permis. Si
vous voulez rendre locale une variable de paquetage du même nom,
qualifiez-la avec le nom du paquetage. 

=item Can't localize pseudo-hash element

(Impossible de rendre local un élément de pseudo-hachage) (F) Vous
avez écrit quelque chose comme C<< local $tab->{'clef'} >>, où
C<$tab> est une référence vers un pseudo-hachage. Cela n'a pas encore
été implémenté mais vous pouvez obtenir un effet similaire en rendant
local l'élément du tableau correspondant directement --- C<< local
$tab->[$tab->[0]{'clef'}] >>. 

=item Can't localize through a reference

(Impossible de rendre locale via une référence) (F) Vous avez écrit
quelque chose comme C<local $$ref>, ce que Perl ne sait actuellement
pas gérer car quand il va restaurer l'ancienne valeur de ce vers quoi
C<$ref> pointait après que la portée du C<local> est terminée, il ne
peut être sûr que C<$ref> soit toujours une référence. 

=item Can't locate %s

(Impossible de trouver I<%s>) (F) Vous avez écrit de faire un C<do>
(ou un C<require> ou un C<use>) sur un fichier qui n'a pu être
trouvé. Perl cherche le fichier dans tous les emplacements mentionnés
dans C<@INC>, à moins que le nom du fichier ne précise son chemin
complet. Peut-être avez-vous besoin de positionner la variable
d'environnement C<PERL5LIB> ou C<PERL5OPT> pour indiquer où se trouve
la bibliothèque ou il est possible que le script ait besoin d'ajouter
le nom de la bibliothèque à C<@INC>. Ou enfin, vous avez peut-être
seulement mal épelé le nom du fichier. Cf. L<perlfunc/require> et
L<lib>.

=item Can't locate auto/%s.al in @INC

(Impossible de trouver C<auto/>I<%s>C<.al> dans C<@INC>) (F) Une
fonction (ou une méthode) a été appelée dans un paquetage qui
autorise le chargement automatique mais il n'existe pas de fonction à
charger automatiquement. Les causes les plus probables sont une faute
de frappe dans le nom de la fonction ou de la méthode ou un échec
dans l'C<AutoSplit> du fichier, disons, lors du C<make install>. 

=item Can't locate object method "%s" via package "%s"

(Impossible de trouver la méthode objet « I<%s> » via le paquetage
I<%s>) (F) Vous avez appelé une méthode correctement et vous avez
correctement indiqué un paquetage fonctionnant comme une classe mais
ce paquetage ne définit pas cette méthode-là, ni aucune de ses classes
de base. Cf. L<perlobj>.

=item Can't locate package %s for @%s::ISA

(Impossible de trouver le paquetage I<%s> pour C<@>I<%s>C<::ISA>)
(W syntax) Le tableau C<@ISA> contient le nom d'un autre paquetage
qui semble ne pas exister. 

#if defined(perldiag580)
=item Can't locate PerlIO%s

(F) You tried to use in open() a PerlIO layer that does not exist,
e.g. open(FH, ">:nosuchlayer", "somefile").

#endif
=item Can't make list assignment to \%ENV on this system

(Impossible d'assigner une liste à C<\%ENV> sur ce système) (F)
L'affectation d'une liste à C<%ENV> n'est pas supporté sur certains
systèmes, notamment VMS. 

=item Can't modify %s in %s

(Impossible de modifier I<%s> dans I<%s>) (F) Vous n'êtes pas
autorisé à faire d'affectation sur l'élément indiqué, ou à essayer de
le changer autrement, comme avec une incrémentation automatique. 

=item Can't modify nonexistent substring

(Impossible de modifier une sous-chaîne inexistante) (P) La routine
interne qui fait l'affectation C<substr> a capturé un NULL. 

=item Can't modify non-lvalue subroutine call

(Impossible de modifier un appel de sous-programme qui ne soit pas
une lvalue) (F) Les sous-programmes destinés à être utilisés dans un
contexte de lvalue doivent être déclarés en tant que tels. 
Cf. L<perlsub/"Lvalue subroutines">.

=item Can't msgrcv to read-only var

(C<msgrcv> d'une var en lecture seule impossible) (F) La cible d'un
C<msgrcv> doit être modifiable pour être utilisée comme un tampon de
réception. 

=item Can't "next" outside a loop block

(« C<next> » impossible vers l'extérieur d'un bloc de boucle) (F) Une
instruction C<next> a été exécutée pour recommencer le bloc courant
mais il n'existe pas de bloc courant. Remarquez que les blocs C<if> ou
C<else> ne comptent pas comme des blocs de boucle, tout comme les
blocs passés à C<sort>, C<map> ou C<grep>. Vous pouvez habituellement
doubler les accolades pour obtenir le même effet, car les accolades
intérieures seront considérées comme un bloc qui boucle une seule
fois. Cf. L<perlfunc/next>.

=item Can't open %s: %s

(Impossible d'ouvrir I<%s> : I<%s>) (S inplace) L'ouverture implicite
d'un fichier via le handle de fichier C<< <> >>, soit implicitement
via les options de la ligne de commande B<-n> ou B<-p>, soit
explicitement, a échoué à cause de la raison indiquée. Habituellement
c'est parce que vous n'avez pas les permissions en lecture sur le
fichier que vous avez indiqué sur la ligne de commande. 

#if defined(perldiag580)
=item Can't open a reference

(Impossible d'ouvrir une référence) (W io) Vous avez essayé d'ouvrir
une référence scalaire en lecture ou en écriture, avec la syntaxe
d'C<open> à 3 arguments :

    open FH, '>', $ref;

mais votre version de perl est compilée sans C<perlio>, et cette forme
d'C<open> n'est pas supportée.

#endif
=item Can't open bidirectional pipe

(Impossible d'ouvrir un pipe bidirectionnel) (W pipe) Vous avez
essayé d'écrire C<open(CMD, "|cmd|")>, ce qui n'est pas supporté.
Vous pouvez essayer l'un des nombreux modules de la bibliothèque Perl
pour faire cela, comme C<IPC::Open2>. Ou alors, dirigez la
sortie du pipe dans un fichier en utilisant C<< > >> et ensuite
lisez-le dans un handle de fichier différent. 

=item Can't open error file %s as stderr

(Impossible d'ouvrir le fichier d'erreur I<%s> comme C<stderr>) (F)
Il s'agit d'une erreur spécifique à VMS. Perl fait ses propres
redirections de la ligne de commande et ne peut ouvrir le fichier
spécifié après C<< 2> >> ou C<< 2>> >> sur la ligne de commande pour
y écrire. 

=item Can't open input file %s as stdin

(Impossible d'ouvrir le fichier d'entrée I<%s> comme C<stdin>) (F) Il
s'agit d'une erreur spécifique à VMS. Perl fait ses propres
redirections de la ligne de commande et ne peut ouvrir le fichier
spécifié après C<< < >> sur la ligne de commande pour y lire. 

=item Can't open output file %s as stdout

(Impossible d'ouvrir le fichier de sortie I<%s> comme C<stdout>) (F)
Il s'agit d'une erreur spécifique à VMS. Perl fait ses propres
redirections de la ligne de commande et ne peut ouvrir le fichier
spécifié après C<< > >> ou C<< >> >> sur la ligne de commande pour y
écrire. 

=item Can't open output pipe (name: %s)

(Impossible d'ouvrir le pipe de sortie (nom : I<%s>)) (P) Il s'agit
d'une erreur spécifique à VMS. Perl fait ses propres redirections de
la ligne de commande et ne peut ouvrir le pipe dans lequel envoyer
les données destinées à C<STDOUT>. 

#if defined(perldiag561) or defined(perldiag560)
=item Can't open perl script "%s": %s

(Impossible d'ouvrir le script perl « I<%s> » : I<%s>) (F) Le script
que vous avez spécifié ne peut être ouvert pour la raison indiquée. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Can't open perl script%s: %s

(Impossible d'ouvrir le script perl « I<%s> » : I<%s>) (F) Le script
que vous avez spécifié ne peut être ouvert pour la raison indiquée. 

#endif
=item Can't read CRTL environ

(Impossible de lire l'environnement de CRTL) (S) Il s'agit d'un
avertissement spécifique à VMS. Perl a essayé de lire un élément de
C<%ENV> depuis le tableau d'environnement interne de CRTL et a
découvert que le tableau n'existait pas. Vous devez déterminer où
CRTL a incorrectement placé son environnement ou définir
C<PERL_ENV_TABLES> (voir I<perlvms>(1)) pour que le tableau
d'environnement ne soit pas recherché. 

=item Can't redefine active sort subroutine %s

(Impossible de redéfinir le sous-programme de C<sort> actif) (F) Perl
optimise la gestion interne des sous-programmes de C<sort> et garde
des pointeurs vers ceux-ci. Vous avez essayé de redéfinir un de ces
sous-programmes de C<sort> alors qu'il était actuellement actif, ce
qui n'est pas permis. Si vous voulez vraiment faire cela, vous devez
écrire C<sort { &fonc } @x> au lieu de C<sort fonc @x>. 

=item Can't "redo" outside a loop block

(« C<redo> » impossible vers l'extérieur d'un bloc de boucle) (F) Une
instruction C<redo> a été exécutée pour recommencer le bloc courant
mais il n'existe pas de bloc courant. Remarquez que les blocs C<if> ou
C<else> ne comptent pas comme des blocs de boucle, tout comme les
blocs passés à C<sort>, C<map> ou C<grep>. Vous pouvez habituellement
doubler les accolades pour obtenir le même effet, car les accolades
intérieures seront considérées comme un bloc qui boucle une seule
fois. Cf. L<perlfunc/redo>.

=item Can't remove %s: %s, skipping file

(Impossible de supprimer I<%s> : I<%s>, fichier passé) (S inplace)
Vous avez demandé une édition sur place sans créer un fichier de
sauvegarde. Perl a été incapable de supprimer le fichier original
pour le remplacer avec celui modifié. Le fichier a été laissé
inchangé. 

=item Can't rename %s to %s: %s, skipping file

(Impossible de renommer I<%s> en I<%s> : I<%s>, fichier passé) (S
inplace) Le renommage effectué par l'option C<-i> a échoué pour une
raison ou pour une autre, probablement parce que vous n'avez pas le
droit d'écrire dans le répertoire. 

=item Can't reopen input pipe (name: %s) in binary mode

(Impossible de rouvrir le pipe d'entrée (nom : I<%s>) en mode
binaire) (P) Il s'agit d'une erreur spécifique à VMS. Perl pensait
que C<STDIN> était un pipe et a essayé de le rouvrir pour accepter
des données binaires. Hélas, cela a échoué. 

=item Can't resolve method `%s' overloading `%s' in package `%s'

(Impossible de résoudre la méthode « I<%s> » surchargeant « I<%s> »
dans le paquetage « I<%s> ») (F|P) Une erreur s'est produite lors de
la résolution de la surcharge spécifiée par un nom de méthode (à
l'inverse d'une référence de sous-programme) : aucune méthode de ce
nom ne peut être appelée via ce paquetage. Si le nom de la méthode
est C<???>, il s'agit d'une erreur interne. 

=item Can't reswap uid and euid

(Impossible d'échanger à nouveau l'uid et l'euid) (P) L'appel
C<setreuid> a échoué pour une raison ou pour une autre dans
l'émulateur setuid de I<suidperl>. 

=item Can't return %s from lvalue subroutine

(Impossible de renvoyer %s d'un sous-programme utilisé comme lvalue)
(F) Perl a détecté que la valeur renvoyée par un sous-programme
utilisé comme lvalue est illégale (constante ou variable temporaire).
C'est interdit. 

=item Can't return outside a subroutine

(C<return> impossible à l'extérieur d'un sous-programme) (F)
L'instruction C<return> a été exécutée dans le fil principal du code,
c'est-à-dire là où il n'y a aucun appel de sous-programme dont on
peut revenir avec C<return>. Cf. L<perlsub>.

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Can't return %s to lvalue scalar context

(Impossible de renvoyer I<%s> pour un contexte scalaire de lvalue) (F)
Vous avez essayé de renvoyer un tableau ou un hachage complet au retour
d'un sous-programme lvalue, mais vous avez appelé ce sous-programme d'une
façon qui fait que Perl pense que vous ne retourneriez qu'une valeur. 
Vous vouliez vraisemblablement ajouter des parenthèses de part et d'autre de
l'appel du sous-programme, ce qui indique à Perl que l'appel s'effectue en
contexte de liste.

#endif
=item Can't stat script "%s"

(C<stat> du script impossible : I<%s>) (P) Pour une raison ou pour
une autre, vous ne pouvez faire de C<fstat> sur le script même si
vous l'avez déjà ouvert. Bizarre. 

=item Can't swap uid and euid

(Impossible d'échanger l'uid et l'euid) (P) L'appel C<setreuid> a
échoué pour une raison ou pour une autre dans l'émulateur setuid de
I<suidperl>. 

=item Can't take log of %g

(Impossible de calculer le log de I<%g>) (F) Pour les nombres réels
ordinaires, vous ne pouvez calculer le logarithme d'un nombre négatif
ou nul. Il existe toutefois un paquetage C<Math::Complex> livré
en standard avec Perl, si c'est vraiment ce que vous voulez faire
cela avec les nombres négatifs. 

=item Can't take sqrt of %g

(Impossible de calculer la racine carrée de I<%g>) (F) Pour les
nombres réels ordinaires, vous ne pouvez calculer la racine carrée
d'un nombre négatif. Il existe toutefois le paquetage
C<Math::Complex> livré en standard avec Perl, si vous voulez
vraiment faire cela. 

=item Can't undef active subroutine

(C<undef> du sous-programme actif impossible) (F) Vous ne pouvez
rendre indéfinie une fonction qui est actuellement utilisée.
Cependant, vous pouvez la redéfinir pendant qu'elle tourne et même
faire un C<undef> sur le sous-programme redéfini pendant que l'ancien
tourne. Maintenant, c'est à vous de voir. 

=item Can't unshift

(C<unshift> impossible) (F) Vous avez essayé de faire un C<unshift>
sur un tableau « irréel » qui ne peut accepter cette opération, comme
la pile principale de Perl. 

=item Can't upgrade that kind of scalar

(Impossible de mettre à niveau ce type de scalaire) (P) La routine
interne C<sv_upgrade> a ajouté des « membres » à un SV, ce qui fait
qu'il se trouve dans une sorte de SV plus spécialisée. Les différents
types les plus élevés de SV sont cependant si spécialisés, qu'ils ne
peuvent être convertis entre eux. Ce message indique qu'une telle
conversion a été tentée. 

=item Can't upgrade to undef

(Impossible de mettre à niveau vers C<undef>) (P) Le SV indéfini
représente le niveau zéro de l'évolutivité. L'évolution vers C<undef>
indique une erreur dans le code appelant C<sv_upgrade>. 

#if defined(perldiag580) or defined(perldiag573)
=item Can't use anonymous symbol table for method lookup

(Impossible d'utiliser une table de symboles anonyme pour la recherche
d'une méthode) (P) La routine interne qui recherche les méthodes a réçu
une table de symboles qui n'a pas de nom. Les tables de symboles peut
devenir anonymes par une ligne telle que : C<undef %Un::Paquetage::>.

#endif
=item Can't use an undefined value as %s reference

(Impossible d'utiliser une valeur indéfinie comme référence de I<%s>)
(F) Une valeur utilisée soit comme une référence en dur, soit comme
une référence symbolique doit avoir une valeur définie. Cela aide à
débloquer certaines erreurs insidieuses. 

=item Can't use bareword ("%s") as %s ref while "strict refs" in use

(Impossible d'utiliser un mot brut (« C<%s> ») en tant que ref de
I<%s> pendant que « C<strict refs> » est actif) (F) Les références en
dur sont les seules autorisées par C<strict refs>. Les références
symboliques sont interdites. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Can't use %! because Errno.pm is not available

(Impossible d'utiliser C<%!> car C<Errno.pm> est indisponible) (F)
La première fois que le hachage C<%!> est utilisé, perl charge automatiquement
le module C<Errno.pm>. Ce module devrait effectuer une liaison sur le 
hachage C<%!> de manière à fournir des noms symboliques pour les valeurs de C<$!>.

#endif
#if defined(perldiag560)
=item Can't use %%! because Errno.pm is not available

(Impossible d'utiliser C<%%!> car C<Errno.pm> n'est pas disponible)
(F) La première fois que le hachage C<%!> est utilisé, Perl charge
automatiquement le module C<Errno>. On attend du module C<Errno>
qu'il se lie avec C<tie> au hachage C<%!> pour fournir des noms
symboliques pour les valeurs des numéros d'erreur de C<$!>. 

#endif
=item Can't use %s for loop variable

(Impossible d'utiliser I<%s> comme variable de boucle) (F) Seule une
variable scalaire simple peut être utilisée comme variable de boucle
dans un C<foreach>. 

=item Can't use global %s in "my"

(Impossible d'utiliser la variable globale I<%s> dans « C<my> ») (F)
Vous avez essayé de déclarer une variable magique en tant que
variable lexicale. Cela n'est pas permis car la variable magique ne
peut être liée qu'à un seul endroit (c'est-à-dire la variable globale) et il
serait incroyablement confus d'avoir des variables dans votre
programme qui ressemblent à des variables magiques mais qui n'en sont
pas. 

=item Can't use "my %s" in sort comparison

(Impossible d'utiliser « C<my> I<%s> » dans les comparaisons de
C<sort>) (F) Les variables globales C<$a> et C<$b> sont réservées
pour les comparaisons de C<sort>. Vous avez mentionné C<$a> ou C<$b>
dans la même ligne que les opérateurs C<< <=> >> ou C<cmp> et la
variable avait été déclarée précédemment en tant que variable
lexicale. Soit qualifiez la variable de C<sort> avec le nom de
paquetage, soit renommez la variable lexicale. 

=item Can't use %s ref as %s ref

(Impossible d'utiliser la ref I<%s> en tant que ref de I<%s>) (F)
Vous avez mélangé vos types de références. Vous devez déréférencer la
référence du type nécessaire. Vous pouvez utilisez la fonction C<ref>
pour tester le type de la référence, si besoin est. 

=item Can't use string ("%s") as %s ref while "strict refs" in use

(Impossible d'utiliser une chaîne (« C<%s> ») en tant que ref de I<%s>
pendant que « C<strict refs> » est actif) (F) Les références en dur
sont les seules autorisées par C<strict refs>. Les références
symboliques sont interdites. Cf. L<perlref>.

=item Can't use subscript on %s

(Impossible d'utiliser un indice sur I<%s>) (F) Le compilateur a
essayé d'interpréter une expression entre crochets en tant qu'indice.
Mais à gauche des crochets, il y avait une expression qui ne
ressemblait pas à une référence de tableau ni à quoi que ce soit que
l'on puisse indicer. 

=item Can't use \%c to mean $%c in expression

(Impossible d'utiliser C<\>I<%c> pour signifier C<$>I<%c> dans une
expression) (W syntax) Dans une expression ordinaire, l'antislash est
un opérateur unaire qui crée une référence vers son argument.
L'utilisation d'un antislash pour indiquer une référence arrière vers
une sous-chaîne réussissant la correspondance n'est valide qu'à
l'intérieur du motif de l'expression régulière. Essayer de faire cela
dans un code ordinaire Perl produit une valeur qui s'affiche comme
C<SCALAR(0xdecaf)>. Utilisez la forme C<$1> à la place. 

=item Can't weaken a nonreference

(Impossible d'affaiblir une non-référence) (F) Vous avez tenté
d'affaiblir quelque chose qui n'était pas une référence. Seules les
références peuvent être affaiblies. 

=item Can't x= to read-only value

(C<x=> impossible sur une valeur en lecture seule) (F) Vous avez
essayé de répéter une valeur constante (souvent la valeur indéfinie)
avec un opérateur d'affectation, ce qui implique de modifier la
valeur elle même. Peut-être devriez-vous copier la valeur dans une
variable temporaire, et répéter cela. 

#if defined(perldiag560)
=item Character class syntax [%s] belongs inside character classes

(La syntaxe C<[>I<%s>C<]> pour une classe de caractères appartient
aux classes de caractères) (W unsafe) Les constructions de classes de
caractères C<[: :]>, C<[= =]> et C<[. .]> se rangent dans les classes
de caractères, par exemple : C</[012[:alpha:]345]/>. Remarquez que
les constructions C<[= =]> et C<[. .]> ne sont pas implémentées
actuellement ; ce sont juste des places réservées pour de futures
extensions. 

#endif
#if defined(perldiag560)
=item Character class syntax [. .] is reserved for future extensions

(Syntaxe C<[. .]> pour une classe de caractère réservée pour de
futures extensions) (W regexp) À l'intérieur des classes de
caractères dans les expressions régulières (C<[]>), la syntaxe
commençant par C<[.> et se terminant par C<.]> est réservée pour de
futures extensions. Si vous avez besoin de représenter de telles
séquences de caractères à l'intérieur d'une classe de caractères dans
une expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[.> et C<.\]>. 

#endif
#if defined(perldiag560)
=item Character class syntax [= =] is reserved for future extensions

(Syntaxe C<[= =]> pour une classe de caractère réservée pour de
futures extensions) (W regexp) A l'intérieur des classes de
caractères dans les expressions régulières (C<[]>), la syntaxe
commençant par C<[=> et se terminant par C<=]> est réservée pour de
futures extensions. Si vous avez besoin de représenter de telles
séquences de caractères à l'intérieur d'une classe de caractères dans
une expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[=> et C<=\]>. 

#endif
#if defined(perldiag560)
=item Character class [:%s:] unknown

(Classe de caractères C<[:>I<%s>C<:]> inconnue) (F) La classe dans la
syntaxe pour une classe de caractères C<[: :]> est inconnue. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Character in "C" format wrapped

(Caractère réduit dans un format « C ») (W pack) Vous avez écrit

    pack("C", $x)

avec C<$x> inférieur à 0, ou supérieur à 255 ; le format C<"C"> est utilisé
uniquement pour l'encodage des caractères natifs du système d'exploitation
(ASCII, EBCDIC, etc), pas pour les caractères Unicode, et Perl se comporte
donc comme si vous aviez écrit

    pack("C", $x & 255)

Si vous voulez réellement utiliser des caractères Unicode, utilisez le
format C<"U"> à la place.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Character in "c" format wrapped

(Caractère réduit dans un format « c ») (W pack) Vous avez écrit

    pack("c", $x)

avec C<$x> inférieur à -128, ou supérieur à 127 ; le format C<"c"> est utilisé
uniquement pour l'encodage des caractères natifs du système d'exploitation
(ASCII, EBCDIC, etc), pas pour les caractères Unicode, et Perl se comporte
donc comme si vous aviez écrit

    pack("c", $x & 255)

Si vous voulez réellement utiliser des caractères Unicode, utilisez le
format C<"U"> à la place.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item chmod() mode argument is missing initial 0

(Il manque le C<0> au début de l'argument représentant le mode de
C<chmod()>) (W chmod) Un utilisateur novice aura tendance à écrire :

  chmod 777, $fichier

en ne réalisant pas que 777 sera interprété comme un nombre décimal,
équivalent à 01411. Les constantes octales sont introduites en les
faisant débuter par un 0 en Perl, tout comme en C.

#endif
#if defined(perldiag560)
=item Close on unopened file <%s>

(Ferme un fichier non ouvert <I<%s>>) (W) Vous avez essayé de fermer
un descripteur de fichier qui n'avait jamais été ouvert. 

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item close() on unopened filehandle %s

(Ferme un  handle de fichier non ouvert I<%s>) (W) Vous avez essayé de fermer
un handle de fichier qui n'avait jamais été ouvert. 

#endif
=item %s: Command not found

(I<%s> : Commande introuvable) (A) Vous avez lancé accidentellement
votre script avec I<csh> au lieu de Perl. Vérifiez la ligne avec
C<#!> ou lancez vous-même votre script manuellement dans Perl avec
I<perl nom_script>. 

=item Compilation failed in require

(Échec de la compilation dans C<require>) (F) Perl n'a pas pu
compiler le fichier spécifié dans une instruction C<require>. Perl
utilise ce message générique lorsqu'aucune des erreurs rencontrées
n'est assez grave pour arrêter la compilation immédiatement. 

=item Complex regular subexpression recursion limit (%d) exceeded

(Limite de récursion atteinte pour les expressions régulières complexes
(I<%d>)) (W regexp) Le moteur d'expressions régulières
utilise la récursion dans les situations complexes où les retours
arrières sont nécessaires. La profondeur de la récursion est limitée
à 32 766, ou peut-être moins sur les architectures où la pile ne peut
croître arbitrairement. (Les situations « simples » et « moyennes »
peuvent être gérées sans récursion et ne sont pas sujettes à une
limite.) Essayez de raccourcir la chaîne examinée, faites des boucles
dans le code Perl (exemple : avec C<while>) plutôt qu'avec le moteur
d'expressions régulières ou réécrivez l'expression régulière pour
qu'elle soit plus simple ou qu'elle contienne moins de retours
arrières. (Cf L<perlfaq2> pour des informations à propos de
I<La maîtrise des Expressions régulières>).

#if defined(perldiag580)
=item cond_broadcast() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to call
cond_broadcast() on a variable which wasn't locked. The cond_broadcast()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.


#endif
#if defined(perldiag580)
=item cond_signal() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to call
cond_signal() on a variable which wasn't locked. The cond_signal()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.

#endif
=item connect() on closed socket %s

(C<connect()> sur une socket fermée I<%s>) (W closed) Vous avez essayé
de faire un C<connect> sur une socket fermée. Peut-être avez-vous
oublié de vérifier la valeur retournée par l'appel de C<socket> ?
Cf. L<perlfunc/connect>.

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Constant(%s)%s: %s

(C<constant(>I<%s>C<)>I<%s> : I<%s>) (F) L'analyseur syntaxique a trouvé
des incohérences soit en tentant de définir une constante surchargée,
soit en essayant de trouver le nom de caractère spécifié dans la
séquence d'échappement C<\N{...}>. Peut-être avez-vous oublié de
charger les pragmas correspondants C<overload> ou C<charnames>. 
Cf. L<charnames> et L<overload>.

#endif
#if defined(perldiag560)
=item constant(%s): %s

(C<constant(>I<%s>C<)> : I<%s>) (F) L'analyseur syntaxique a trouvé
des incohérences soit en tentant de définir une constante surchargée,
soit en essayant de trouver le nom de caractère spécifié dans la
séquence d'échappement C<\N{...}>. Peut-être avez-vous oublié de
charger les pragmas correspondants C<overload> ou C<charnames>. 

#endif
=item Constant is not %s reference

(La constante n'est pas une référence de I<%s>) (F) Une valeur
constante (déclarée peut-être en utilisant le pragma C<use constant>)
est déréférencée mais équivaut à une référence d'un mauvais type. Le
message indique le type de référence qui était attendu. Ceci indique
habituellement une erreur de syntaxe en déréférençant la valeur
constante. Cf. L<perlsub/"Constant Functions"> et L<constant>.

=item Constant subroutine %s redefined

(Sous-programme constant I<%s> redéfini) (S|W redefine) Vous avez
redéfini un sous-programme qui a été désigné auparavant comme étant en
ligne (I<inlining>). Cf. L<perlsub/"Constant Functions"> pour des
commentaires et des solutions de contournement.

#if defined(perldiag580)
=item Constant subroutine %s redefined

(S) You redefined a subroutine which had previously been
eligible for inlining.  See L<perlsub/"Constant Functions"> for
commentary and workarounds.

#endif
#if defined(perldiag573) or defined(perldiag561) or defined(perldiag560)
=item Constant subroutine %s undefined

(Sous-programme constant I<%s> indéfini) (W misc) Vous avez rendu
indéfini un sous-programme qui a été désigné auparavant comme étant en
ligne (I<inlining>).  Cf. L<perlsub/"Constant Functions"> pour des
commentaires et des solutions de contournement.

#endif
=item Copy method did not return a reference

(La méthode de copie n'a pas renvoyé de référence) (F) La méthode qui
surcharge C<=> est boguée. Cf. L<overload/Copy Constructor>.

=item CORE::%s is not a keyword

(C<CORE::>I<%s> n'est pas un mot clef) (F) L'espace de noms
C<CORE::> est réservé pour les mots clefs de Perl. 

=item corrupted regexp pointers

(Pointeurs d'expressions régulières corrompus) (P) Le moteur
d'expressions régulières est devenu confus par ce que le compilateur
d'expressions régulières lui a donné. 

=item corrupted regexp program

(Programme d'expressions régulières corrompu) (P) On a passé au
moteur d'expressions régulières un programme d'expression régulières
sans nombre magique valide. 

=item Corrupt malloc ptr 0x%lx at 0x%lx

(Pointeur de C<malloc> C<0x>I<%lx> corrompu en C<0x>I<%lx>) (P) Le
paquetage C<malloc> distribué avec Perl a eu une erreur interne. 

=item C<-p> destination: %s

(Destination de C<-p> : I<%s>) (F) Une erreur est survenue durant
l'affichage sur la sortie standard implicite invoquée par l'option de
la ligne de commande B<-p>. (Cette sortie est redirigée vers
C<STDOUT> à moins que vous ne l'ayez redirigée avec C<select>.) 

=item C<-T> and C<-B> not implemented on filehandles

(C<-T> et C<-B> ne sont pas implémentés sur les handles de fichiers)
(F) Perl ne peut utiliser le tampon d'entrée/sortie du handle de
fichier quand il ne connaît pas votre type d'entrées/sorties
standards. Vous devez utiliser un nom de fichier à la place. 

=item Deep recursion on subroutine "%s"

(Récursion profonde pour le sous-programme « I<%s> ») (W recursion)
Ce sous-programme s'est appelé lui-même (directement ou
indirectement) 100 fois de plus qu'il n'est revenu. Ceci indique
probablement une récursion infinie, à moins que vous n'écriviez un
étrange programme de benchmark, auquel cas cela indique quelque chose
d'autre. 

=item defined(@array) is deprecated

(C<defined(@tableau)> est déprécié) (D deprecated) C<defined> n'est
habituellement pas très utile sur les tableaux car il teste la
présence d'une valeur I<scalaire> indéfinie. Si vous voulez voir si le
tableau est vide, vous n'avez qu'à utiliser C<if (@tableau) { # pas
vide }>.

=item defined(%hash) is deprecated

(C<defined(%hachage)> est déprécié) (D deprecated) C<defined> n'est
habituellement pas très utile sur les hachages car il teste la
présence d'une valeur I<scalaire> indéfinie. Si vous voulez voir si le
hachage est vide, vous n'avez qu'à utiliser C<if (%hachage) { # pas
vide }>.

#if defined(perldiag580) or defined(perldiag573)
=item %s defines neither package nor VERSION--version check failed

(I<%s> ne définit ni paquetage, ni VERSION -- la vérification de la version
a échoué) (F) Vous avez écrit quelque chose du genre C<use Module 42>, mais
le fichier C<Module> ne comporte aucune déclaration de paquetage, et
aucune définition de C<$VERSION>.

#endif
=item Delimiter for here document is too long

(Le délimiteur pour le document « ici-même » est trop long) (F) Dans
une construction de document « ici-même », comme C<< <<TRUC >>,
l'étiquette C<TRUC> est trop longue pour que Perl puisse la gérer. Il
faut que vous soyez sérieusement tordu pour écrire un code qui
déclenche cette erreur. 

=item Did not produce a valid header

(N'a pas produit un en-tête valide) Voir C<Server error>. 

=item %s did not return a true value

(I<%s> n'a pas renvoyé une valeur vraie) (F) Un fichier requis par
C<require> (ou utilisé par C<use>) doit retourner une valeur vraie
pour indiquer qu'il s'est compilé correctement et que
l'initialisation de son code s'est bien passée. Il est traditionnel de
placer un C<1;> à la fin d'un tel fichier, bien qu'une quelconque
valeur qui équiveaut à « vrai » fasse l'affaire. Cf. L<perlfunc/require>.

=item (Did you mean &%s instead?)

(Avez-vous plutôt voulu dire C<&>I<%s> ?) (W) Vous avez probablement
fait référence à un sous-programme importé C<&TRUC> en faisant
C<$TRUC> ou quelque chose du genre. 

=item (Did you mean "local" instead of "our"?)

(Avez-vous voulu dire « local » plutôt que « our » ?) (W misc)
Souvenez-vous que C<our> ne rend pas locale la variable déclarée
comme globale. Vous l'avez redéclarée dans la même portée lexicale,
ce qui semble superflu. 

=item (Did you mean $ or @ instead of %?)

(Avez-vous voulu dire C<$> ou C<@> plutôt que C<%> ?) (W) Vous avez
probablement écrit C<%hachage{$clef}> alors que vous pensiez
C<$hachage{$clef}> ou C<@hachage{@clefs}>. D'un autre côté, peut-être
avez-vous juste voulu dire C<%hachage> et vous vous êtes laissés
emporter. 

=item Died

(Mort) (F) Vous avez appelé à C<die> une chaîne vide (l'équivalent de
C<die "">) ou vous l'avez appelé sans arguments et à la fois C<$@> et
C<$_> étaient vides. 

=item Document contains no data

(Le document ne contient pas de données) Voir C<Server error>. 

#if defined(perldiag580) or defined(perldiag573)
=item %s does not define %s::VERSION--version check failed

(I<%s> ne définit pas I<%s>C<::VERSION> -- la vérification de la version
a échoué) (F)  Vous avez écrit quelque chose du genre C<use Module 42>, mais
le fichier C<Module> ne comporte aucune définition de C<$VERSION>.

#endif
=item Don't know how to handle magic of type '%s'

(Ne sait pas comment gérer la magie du type 'I<%s>') (P) On a jeté un
sort sur la gestion interne des variables magiques. 

=item do_study: out of memory

(C<do_study> : débordement de mémoire) (P) Ce message aurait plutôt
dû être capturé par C<safemalloc>. 

=item (Do you need to predeclare %s?)

(Avez-vous besoin de prédéclarer I<%s> ?) (S) Il s'agit d'une
supposition donnée en complément du message « I<%s> C<found where
operator expected> ». Cela veut souvent dire qu'un nom de
sous-programme ou de module a été référencé alors qu'il n'a pas
encore été défini. C'est peut être un problème d'ordre dans votre
fichier ou parce qu'il manque une instruction C<sub>, C<package>,
C<require> ou C<use>. Si vous référencez quelque chose qui n'est pas
encore défini, en fait vous n'avez pas à définir le sous-programme ou
le paquetage avant cet endroit. Vous pouvez utilisez un C<sub truc;>
ou un C<package TRUC;> vide pour entrer une déclaration « par avance ». 

#if defined(perldiag580) or defined(perldiag573)
=item dump() better written as CORE::dump()

(Plutôt que C<dump()>, il est préférable d'écrire C<CORE::dump()> (W misc)
Vous avez utilisé la fonction interne C<dump()>, frappée d'obsolescence, sans
la qualifier entièrement sous la forme C<CORE::dump()>. Peut-être s'agit-il
d'une faute de frappe. Cf. L<perlfunc/dump>.

#endif
=item Duplicate free() ignored

(Duplication de C<free()> ignorée) (S malloc) Une routine interne a
appelé C<free> sur quelque chose qui a déjà été libéré. 

=item elseif should be elsif

(C<elseif> devrait être C<elsif>) (S) Il n'y a pas de mot-clef 
« C<elseif> » en Perl car Larry pense que c'est très laid. Votre code
sera interprété comme une tentative d'appel à la méthode nommée
C<elseif> pour la classe renvoyée par le bloc qui suit. Ce n'est
sûrement pas ce que vous voulez. 

#if defined(perldiag580) or defined(perldiag573)
=item Empty %s

(I<%s> vide) (F) La propriété C<\p{}> ou C<\P{}> est vide.

#endif
#if defined(perldiag580)
=item Empty %s

(F) C<\p> and C<\P> are used to introduce a named Unicode property, as
described in L<perlunicode> and L<perlre>. You used C<\p> or C<\P> in
a regular expression without specifying the property name.

#endif
#if defined(perldiag573)
=item entering effective %s failed

(L'entrée dans I<%s> effectif a échoué) (F) Alors que le pragma C<use
filetest> était actif, l'échange entre les UID ou les GID réels et
effectifs a échoué. 

#endif
#if defined(perldiag560)
=item entering effective %s failed

(l'entrée dans I<%s> effectif a échoué) (F) Alors que le pragma C<use
filetest> était actif, l'échange entre les UID ou les GID réels et
effectifs a échoué. 

#endif
=item Error converting file specification %s

(Erreur en convertissant la spécification de fichier I<%s>) (F) Il
s'agit d'une erreur spécifique à VMS. Comme Perl doit gérer des
spécifications de fichiers dans les syntaxes VMS ou Unix, il
convertit celles-ci dans un format unique lorsqu'il doit les traiter
directement. Soit vous avez passé des spécifications de fichier
invalides, soit vous avez trouvé un cas que les routines de
conversion ne gèrent pas. Zut ! 

=item %s: Eval-group in insecure regular expression

(I<%s> : Groupe C<eval> dans une expression régulière non sécurisée)
(F) Perl a détecté une donnée marquée en essayant de compiler une
expression régulière qui contient l'assertion de longueur zéro C<(?{
... })> , ce qui n'est pas sécurisé.  Cf. L<perlre/(?{ code })>, et
L<perlsec>.

=item %s: Eval-group not allowed at run time

(I<%s> : Groupe C<eval> interdit à l'exécution) (F) Perl a essayé de
compiler une expression régulière contenant l'assertion de longueur
nulle C<(?{ ... })> à l'exécution, comme il le ferait si le motif
contenait des valeurs interpolées. Comme c'est un risque de sécurité,
cela n'est pas permis. Si vous insistez, vous pouvez toujours le
faire en construisant explicitement votre motif depuis une chaîne
interpolée à l'exécution et l'utiliser dans un C<eval>. 
Cf. L<perlre/(?{ code })>.

=item %s: Eval-group not allowed, use re 'eval'

(I<%s> : Groupe C<eval> interdit, utilisez C<use re 'eval'>) (F) Une
expression régulière contenait l'assertion de longueur nulle 
C<(?{... })>, mais cette construction est seulement permise quand le 
pragma C<use re 'eval'> est actif.  Cf. L<perlre/(?{ code })>.

=item Excessively long <> operator

(Opérateur C<< <> >> excessivement long) (F) Le contenu d'un
opérateur C<< <> >> ne doit pas excéder la taille maximum d'un
identificateur Perl. Si vous essayez seulement d'obtenir les
extensions d'une longue liste de fichiers, essayez d'utiliser
l'opérateur C<glob> ou mettez les noms de fichiers dans une variable
et faites un C<glob> dessus. 

#if defined(perldiag580) or defined(perldiag573)
=item exec? I'm not *that* kind of operating system

(C<exec> ? Je ne suis pas *ce* système d'exploitation) (F) La fonction
C<exec> n'est pas implementée en MacPerl. Cf. L<perlport>.

#endif
=item Execution of %s aborted due to compilation errors

(Exécution de I<%s> abandonnée à cause d'erreurs de compilation) (F)
Le message de résumé final lorsqu'une compilation Perl échoue. 

=item Exiting eval via %s

(Sortie d'un C<eval> via I<%s>) (W exiting) Vous êtes sorti d'un
C<eval> d'une façon non conventionnelle, comme un C<goto> ou une
instruction de contrôle de boucle. 

=item Exiting format via %s

(Sortie d'un C<format> via I<%s>) (W exiting) Vous êtes sorti d'un
C<format> d'une façon non conventionnelle, comme un C<goto> ou une
instruction de contrôle de boucle. 

#if defined(perldiag573)
=item Exiting pseudo-block via %s

(Sortie d'un pseudo-bloc via I<%s>) (W exiting) Vous êtes sorti d'une
construction tout à fait spéciale de bloc (comme un bloc ou un
sous-programme de C<sort>) d'une façon non conventionnelle, comme un
C<goto>, ou une instruction de contrôle de boucle. Cf. L<perlfunc/sort>.

#endif
#if defined(perldiag560)
=item Exiting pseudoblock via %s

(Sortie d'un pseudo-bloc via I<%s>) (W exiting) Vous êtes sorti d'une
construction tout à fait spéciale de bloc (comme un bloc ou un
sous-programme de C<sort>) d'une façon non conventionnelle, comme un
C<goto>, ou une instruction de contrôle de boucle. Cf. L<perlfunc/sort>.

#endif
=item Exiting subroutine via %s

(Sortie d'un sous-programme via I<%s>) (W exiting) Vous êtes sorti
d'un sous-programme d'une façon non conventionnelle, comme un C<goto>
ou une instruction de contrôle de boucle. 

=item Exiting substitution via %s

(Sortie d'une substitution via I<%s>) (W exiting) Vous êtes sorti
d'une substitution d'une façon non conventionnelle, comme un C<goto>
ou une instruction de contrôle de boucle. 

=item Explicit blessing to '' (assuming package main)

(Consécration par C<bless> explicite vers C<''> (paquetage principal
C<main> adopté)) (W misc) Vous avez consacré par C<bless> une
référence à une chaîne de longueur nulle. Cela a pour effet de
consacrer la référence dans le paquetage principal C<main>. Ce n'est
pas habituellement ce que vous voulez. Pensez à fournir un paquetage
cible par défaut, comme dans C<bless($ref, $p || 'Mon_Paquetage');> 

=item %s: Expression syntax

(I<%s> : Syntaxe d'expression ) (A) Vous avez lancé accidentellement
votre script avec I<csh> au lieu de Perl. Vérifiez la ligne avec
C<#!> ou lancez vous-même votre script manuellement dans Perl avec
I<perl nom_script>. 

=item %s failed--call queue aborted

(I<%s> a échoué --- file d'appels abandonnée) (F) Une exception non
capturée a été levée pendant l'exécution d'un sous-programme
C<CHECK>, C<INIT> ou C<END>. Le traitement du reste de la file
contenant de telles routines s'est terminé prématurément. 

#if defined(perldiag580) or defined(perldiag573)
=item False [] range "%s" in regex; marked by <-- HERE in m/%s/

(Faux intervalle C<[]> « I<%s> » dans l'expression régulière) (W
regexp) Un intervalle de classe de caractères doit commencer et finir
par un caractère littéral et non par une autre classe de caractères
comme C<\d> ou C<[:alpha:]>. Le C<-> dans votre faux intervalle est
interprété comme un C<-> littéral. Pensez à protéger le C<-> comme
cela : C<\->. La mention « <-- HERE » indique l'endroit où le
problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item false [] range "%s" in regexp

(faux intervalle C<[]> « I<%s> » dans l'expression régulière) (W
regexp) Un intervalle de classe de caractères doit débuter et finir
par un caractère littéral et non par une autre classe de caractères
comme C<\d> ou C<[:alpha:]>. Le C<-> dans votre faux intervalle est
interprété comme un C<-> littéral. Pensez à protéger le - comme 
cela : C<\->. 

#endif
=item Fatal VMS error at %s, line %d

(Erreur VMS fatale dans I<%s>, ligne I<%d>) (P) Il s'agit d'une
erreur spécifique à VMS. Il s'est passé quelque chose de fâcheux dans
un service du système VMS ou dans une routine CRTL ; le statut de
sortie de Perl devrait fournir plus de détails. Le nom de fichier
dans C<at> I<%s> et le numéro de ligne dans C<line> I<%d> vous
indiquent quelle section du code source Perl a été affectée. 

=item fcntl is not implemented

(C<fcntl> non implémenté) (F) Votre machine n'implémente apparemment
pas C<fcntl>. Qu'est-ce que c'est que ça, un PDP-11 ou quelque chose
de similaire ? 

#if defined(perldiag560)
=item Filehandle %s never opened

(Handle de fichier I<%s> jamais ouvert) (W unopened) Une opération
d'entrée/sortie a été tentée sur un handle de fichier qui n'a jamais
été initialisé. Vous devez faire un appel à C<open> ou à C<socket> ou
appeler un constructeur du module C<FileHandle>. 

#endif
=item Filehandle %s opened only for input

(Handle de fichier I<%s> ouvert seulement pour les entrées) (W io)
Vous avez tenté d'écrire dans un handle de fichier ouvert en lecture
seule. Si vous vouliez que ce soit un handle de fichier ouvert en
lecture-écriture, vous deviez l'ouvrir avec C<< +< >>, C<< +> >> ou
C<< +>> >> au lieu de C<< < >> ou rien du tout. Si vous désiriez
uniquement écrire dans le fichier, utilisez C<< > >> ou C<< >> >>. 
Cf. L<perlfunc/open>.

#if defined(perldiag580)
=item Filehandle %s opened only for input

(W io) You tried to write on a read-only filehandle.  If you intended it
to be a read-write filehandle, you needed to open it with "+<" or "+>"
or "+>>" instead of with "<" or nothing.  If you intended only to write
the file, use ">" or ">>".  See L<perlfunc/open>.
The warning will also occur if STDOUT (file descriptor 1) or STDERR
(file descriptor 2) is opened for input, this is a pre-emptive warning in
case some other part of your program or a child process is expecting STDOUT
and STDERR to be writable. This can happen accidentally if you
C<close(STDOUT)> or STDERR and then C<open> an unrelated handle which
will resuse the lowest numbered available descriptor.

#endif
#if defined(perldiag573) or defined(perldiag561) or defined(perldiag560)
=item Filehandle %s opened only for output

(Handle de fichier I<%s> ouvert seulement pour les sorties) (W io)
Vous avez tenté de lire dans un handle de fichier ouvert en écriture
seule. Si vous vouliez que ce soit un handle de fichier ouvert en
lecture-écriture, vous deviez l'ouvrir avec C<< +< >>, C<< +> >> ou
C<< +>> >> au lieu de C<< < >> ou rien du tout. Si vous désiriez
uniquement lire dans le fichier, utilisez C<< < >>. 
Cf. L<perlfunc/open>.

#endif
#if defined(perldiag580)
=item Filehandle %s opened only for output

(W io) You tried to read from a filehandle opened only for writing.
If you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with "<" or nothing.  If you
intended only to read from the file, use "<".  See L<perlfunc/open>.
The warning will also occur if STDIN (file descriptor 0) is opened
for output - this is a pre-emptive warning in case some other part of your
program or a child process is expecting STDIN to be readable.
This can happen accidentally if you C<close(STDIN)> and then C<open> an
unrelated handle which will resuse the lowest numbered available
descriptor.

#endif
#if defined(perldiag573) or defined(perldiag561) or defined(perldiag560)
=item Final $ should be \$ or $name

(C<$> final devrait être C<\$> ou C<$nom>) (F) Vous devez maintenant
décider si le C<$> final dans une chaîne devait être interprété comme
le signe dollar littéral ou s'il était là pour introduire un nom de
variable s'avérant manquer. Vous devez donc ajouter soit
l'anti-slash, soit le nom. 

#endif
=item Final @ should be \@ or @name

(C<@> final devrait être C<\@> ou C<@nom>) (F) Vous devez maintenant
décider si le C<@> final dans une chaîne devait être interprété comme
le signe arobase littéral ou s'il était là pour introduire un nom de
variable s'avérant manquer. Vous devez donc ajouter soit
l'anti-slash, soit le nom. 

=item flock() on closed filehandle %s

(C<flock()> sur un handle de fichier fermé I<%s>) (W closed) Le
handle de fichier sur lequel vous avez essayé de faire C<flock> a été
lui-même fermé quelque temps auparavant. Vérifiez le flux logique de
votre programme. C<flock> agit sur des handles de fichiers. Avez-vous
tenté d'appeler C<flock> sur un handle de répertoire du même nom ? 

#if defined(perldiag560)
=item ?+* follows nothing in regexp

(C<?+*> ne suivent rien dans l'expression régulière) (F) Vous avez
commencé une expression rationnelle avec un quantifiant. Mettez un
anti-slash devant si vous vouliez l'employer au sens littéral. 
Cf.  L<perlre>.

#endif
=item Format not terminated

(Format inachevé) (F) Un format doit être terminé par une ligne
contenant uniquement un point. Perl est arrivé en fin de fichier sans
trouver une telle ligne. 

#if defined(perldiag580) or defined(perldiag573)
=item Format %s redefined

(Format I<%s> redéfini) (W redefine) Vous avez redéfini un format.
Pour supprimer cet avertissement, écrivez 

    {
	no warnings 'redefine';
	eval "format NAME =...";
    }

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Format %s redefined

(Format I<%s> redéfini) (W redefine) Vous avez redéfini un format.
Pour supprimer cet avertissement, écrivez 

  {
      no warnings;
      eval "format NAME =...";
  }

#endif
=item Found = in conditional, should be ==

(C<=> trouvé dans une condition, devrait être C<==>) (W syntax) Vous
avez écrit :

  if ($truc = 123)

alors que vous vouliez dire :

  if ($truc == 123)

(ou quelque chose de similaire).

#if defined(perldiag561) or defined(perldiag560)
=item %s found where operator expected

(I<%s> trouvé là où l'on attendait un opérateur) (S) L'analyseur
lexicographique de Perl sait s'il attend un terme ou un opérateur.
S'il voit ce qu'il sait être un terme alors qu'il s'attend à un
opérateur, il vous donne ce message d'alerte. Habituellement, cela
indique qu'un opérateur ou un séparateur a été omis, comme un point
virgule. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item %s found where operator expected

(I<%s> trouvé là où l'on attendait un opérateur) (S) L'analyseur
lexical de Perl sait s'il attend un terme ou un opérateur.
S'il voit ce qu'il sait être un terme alors qu'il s'attend à un
opérateur, il vous donne ce message d'alerte. Habituellement, cela
indique qu'un opérateur ou un séparateur a été omis, comme un point
virgule. 

#endif
=item gdbm store returned %d, errno %d, key "%s"

(Le stockage gdbm a renvoyé I<%d>, numéro d'erreur I<%d>, clef 
« I<%s> ») (S) Un avertissement de l'extension C<GDBM_File> indique
qu'un stockage a échoué. 

=item gethostent not implemented

(C<gethostent> non implémenté) (F) Votre bibliothèque C n'implémente
apparemment pas C<gethostent>, probablement parce que si elle le
faisait, elle se sentirait moralement obligée de renvoyer chaque nom
d'hôte existant sur Internet. 

=item get%sname() on closed socket %s

(C<get>I<%s>C<name()> sur une socket fermée I<%s>) (W closed) Vous
avez essayé d'obtenir une socket ou une socket parente d'une socket
fermée. Peut-être avez-vous oublié de vérifier la valeur renvoyée par
l'appel C<socket> ? 

=item getpwnam returned invalid UIC %#o for user "%s"

(C<getpwname> a renvoyé l'UIC C<%#o> invalide pour l'utilisateur 
« I<%s> ») (S) Il s'agit d'un avertissement spécifique à VMS. L'appel à
C<sys$getuai>, sous-jacent de l'opérateur C<getpwnam>, a retourné une
UIC invalide. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item getsockopt() on closed socket %s

(C< getsockopt()> sur une socket fermée I<%s>) (W closed) Vous avez
essayé d'obtenir une option de socket sur une socket fermée. Peut-être
avez-vous oublié de vérifier la valeur renvoyée par l'appel C<socket> ?  
Cf. L<perlfunc/getsockopt>.

#endif
=item Global symbol "%s" requires explicit package name

(Le symbole global « I<%s> » exige un nom de paquetage explicite) (F)
Vous avez écrit C<use strict vars>, ce qui indique que toutes les
variables doivent soit avoir une portée lexicale (en utilisant
C<my>), soit être déclarées au préalable en utilisant C<our>, soit
être explicitement qualifiées pour dire à quel paquetage la variable
globale appartient (en utilisant C<::>). 

=item glob failed (%s)

(Échec du C<glob>) (W glob) Quelque chose s'est mal passé avec le(s)
programme(s) externe(s) utilisé(s) par C<glob> et C<< <*.c> >>.
Habituellement, cela signifie que vous avez fourni un motif de
C<glob> qui a entraîné l'échec du programme externe qui s'est terminé
avec un statut différent de zéro. Si le message indique que la sortie
anormale a engendré un vidage de la mémoire (I<core dump>),
ceci peut également vouloir dire que votre I<csh> (C shell) est
corrompu. Si c'est le cas, vous devriez changer toutes les variables
se rapportant à I<csh> dans I<config.sh>. Si vous utilisez I<tcsh>,
changez les variables qui s'y réfèrent comme si c'était I<csh>. (ex.
C<full_csh='/usr/bin/tcsh'>) ; sinon, videz-les toutes (sauf C<d_csh>
qui devrait valoir C<'undef'>) pour que Perl croit qu'il manque
I<csh>. Dans tous les cas, une fois I<config.sh> mis à jour, lancez
I<./Configure -S> et reconstruisez Perl. 

=item Glob not terminated

(Glob non terminé) (F) L'analyseur lexical a vu un signe inférieur à
un endroit où il s'attendait à trouver un terme, il recherche donc le
signe supérieur correspondant et ne le trouve pas. Il y a des chances
que vous ayez oublié des parenthèses nécessaires auparavant dans la
ligne et que vous avez réellement voulu dire le symbole C<< < >>. 

=item Got an error from DosAllocMem

(Erreur rencontrée depuis C<DosAllocMem>) (P) Il s'agit d'une erreur
spécifique à OS/2. Le plus probable est que vous employez une version
obsolète de Perl, cette erreur ne devrait donc jamais se produire de
toute façon. 

=item goto must have label

(C<goto> doit avoir une étiquette) (F) Au contraire de C<next> et de
C<last>, vous n'êtes pas autorisés à faire un C<goto> vers une
destination non spécifiée. Cf. L<perlfunc/goto>.

#if defined(perldiag580) or defined(perldiag573)
=item %s-group starts with a count

(Un groupe I<%s> commence par un compte) (F) Un groupe C<()> commence par un compte 
dans C<pack>/C<unpack>). Un compte doit toujours succéder à quelque chose :
un caractère de canevas ou un groupe C<()>.

#endif
=item %s had compilation errors

(I<%s> a engendré des erreurs de compilation) (F) C'est le message
final lorsqu'un I<perl -c> échoue. 

=item Had to create %s unexpectedly

(A dû créer I<%s> de manière inattendue) (S internal) Une routine a
demandé un symbole dans une table des symboles qui aurait dû déjà
exister mais pour une raison ou pour une autre ce n'était pas le cas
elle a été crée en urgence pour éviter un vidage de la mémoire
(I<core dump>). 

=item Hash %%s missing the % in argument %d of %s()

(Il manque le C<%> du hachage C<%>I<%s> dans l'argument I<%d> de
I<%s>()) (D deprecated) Seules les versions de Perl vraiment
anciennes vous permettaient d'omettre le C<%> dans les noms de
hachage à certains endroits. C'est maintenant largement déprécié. 

=item %s has too many errors

(I<%s> a engendré trop d'erreurs) (F) L'analyseur abandonne son
analyse du programme après 10 erreurs. Les messages suivant ne
seraient pas sensés. 

=item Hexadecimal number > 0xffffffff non-portable

(Nombre hexadécimal > C<0xffffffff>, non portable) (W portable) Le
nombre hexadécimal que vous avez spécifié est plus grand que
C<2**32-1> (4 294 967 295) et n'est donc pas portable d'un système à
l'autre.  Cf. L<perlport> pour de plus amples renseignements sur les
questions de portabilité.

=item Identifier too long

(Identificateur trop long) (F) Perl limite la taille des
identificateurs (noms des variables, fonctions, etc.) à 250
caractères environ pour les noms simples et un peu plus pour les noms
composés (comme C<$A::B>). Vous avez dépassé les limites de
Perl. Les futures versions de Perl seront susceptibles d'éliminer ces
limitations arbitraires. 

#if defined(perldiag560)
=item Illegal binary digit

(Chiffre binaire illégal) (F) Vous avez utilisé un chiffre autre que
0 ou 1 dans un nombre binaire. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Illegal binary digit %s

(Chiffre binaire illégal) (F) Vous avez utilisé un chiffre autre que
0 ou 1 dans un nombre binaire. 

#endif
=item Illegal binary digit %s ignored

(Chiffre binaire illégal I<%s>, ignoré) (W digit) Vous avez essayé
d'utiliser un chiffre autre que 0 ou 1 dans un nombre binaire.
L'interprétation du nombre binaire s'est arrêtée avant le chiffre en
cause. 

=item Illegal character %s (carriage return)

(Caractère illégal I<%s> (retour chariot)) (F) D'ordinaire, Perl
traite les retours chariots dans le texte du programme au même titre
que n'importe quel autre caractère d'espacement, ce qui signifie que
vous ne devriez jamais voir cette erreur lorsque Perl a été construit
en utilisant les options standards. Pour une raison ou pour une
autre, votre version de Perl semble avoir été construite sans ce
support. Parlez-en à votre administrateur Perl. 

#if defined(perldiag580) or defined(perldiag573)
=item Illegal character in prototype for %s : %s

(Caractère illégal dans le prototype pour I<%s> : I<%s>) (W syntax)
Un caractère illégal a été trouvé dans la déclaration d'un prototype. 
Les caractères légaux sont  C<$>, C<@>, C<%>, C<*>, C<;>, C<[>, C<]>, C<&>, et C<\>.

#endif
=item Illegal division by zero

(Division par zéro illégale) (F) Vous avez essayé de diviser un
nombre par 0. Soit quelque chose clochait dans votre logique, soit
vous devez placer une condition pour vous préserver de cette entrée
dénuée de sens.

=item Illegal hexadecimal digit %s ignored

(Chiffre hexadécimal illégal I<%s>, ignoré) (W digit) Vous avez
essayé d'utiliser un caractère autre qui n'est ni entre C<0> et C<9>,
ni entre C<A> et C<F>, ni entre C<a> et C<f> dans un nombre
hexadécimal. L'interprétation du nombre hexadécimal s'est arrêtée
avant le caractère illégal. 

=item Illegal modulus zero

(Modulo zéro illégal) (F) Vous avez essayé de diviser un nombre par 0
pour obtenir le reste. La plupart des nombres ne le prennent pas
gentiment. 

=item Illegal number of bits in vec

(Nombre de bits illégal dans C<vec>) (F) Le nombre de bits dans
C<vec> (le troisième argument) doit être une puissance de deux de 1 à
32 (ou 64 si votre plate-forme le supporte). 

#if defined(perldiag561) or defined(perldiag560)
=item Illegal octal digit

(Chiffre octal illégal) (F) Vous avez utilisé un 8 ou un 9 dans un
nombre octal. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Illegal octal digit %s

(Chiffre octal illégal) (F) Vous avez utilisé un 8 ou un 9 dans un
nombre octal. 

#endif
=item Illegal octal digit %s ignored

(Chiffre octal illégal I<%s>, ignoré ) (W digit) Vous avez peut-être
essayé d'utiliser un 8 ou un 9 dans un nombre octal. L'interprétation
du nombre octal s'est arrêtée avant le 8 ou le 9. 

#if defined(perldiag561) or defined(perldiag560)
=item Illegal switch in PERL5OPT: %s

(Option illégale dans C<PERL5OPT> : I<%s>) (X) La variable
d'environnement C<PERL5OPT> ne peut être utilisée que pour
positionner les options suivantes : B<-[DIMUdmw]>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Illegal switch in PERL5OPT: %s

(Option illégale dans C<PERL5OPT> : I<%s>) (X) La variable
d'environnement C<PERL5OPT> ne peut être utilisée que pour
positionner les options suivantes : B<-[DIMUdmtw]>. 

#endif
=item Ill-formed CRTL environ value "%s"

(Valeur d'environnement de CRTL « I<%s> » mal formée) (W internal) Il
s'agit d'un avertissement spécifique à VMS. Perl a essayé de lire le
tableau d'environnement interne de CRTL et a rencontré un élément
sans le séparateur C<=> utilisé pour séparer les clefs des valeurs.
L'élément est ignoré. 

=item Ill-formed message in prime_env_iter: |%s|

(Message mal formé dans C<prime_env_iter> : C<|>I<%s>C<|>) (W
internal) Il s'agit d'un avertissement spécifique à VMS. Perl a
essayé de lire un nom logique ou une définition de symbole CLI en se
préparant à parcourir C<%ENV> et il n'a pas vu le séparateur attendu
entre les clefs et les valeurs, la ligne a donc été ignorée. 

#if defined(perldiag560)
=item (in cleanup) %s

((au nettoyage) I<%s>) (W misc) Ce préfixe indique habituellement
qu'une méthode C<DESTROY> a levé l'exception indiquée. Puisque les
destructeurs sont appelés habituellement par le système à un moment
arbitraire durant l'exécution, et bien souvent un grand nombre de
fois, cet avertissement n'est affiché qu'une seule fois pour tous les
échecs qui sinon auraient causé une répétition du même message.

Les échecs des fonctions de rappel (I<callbacks>) définies par
l'utilisateur et propagées par l'emploi du flag C<G_KEEPERR> peuvent
également entraîner cet avertissement. Voir I<perlcall>(1).

#endif
#if defined(perldiag580) or defined(perldiag573)
=item (in cleanup) %s

((au nettoyage) I<%s>) (W misc) Ce préfixe indique habituellement
qu'une méthode C<DESTROY> a levé l'exception indiquée. Puisque les
destructeurs sont appelés habituellement par le système à un moment
arbitraire durant l'exécution, et bien souvent un grand nombre de
fois, cet avertissement n'est affiché qu'une seule fois pour tous les
échecs qui sinon auraient causé une répétition du même message.

Les échecs des fonctions de rappel (I<callbacks>) définies par
l'utilisateur et propagées par l'emploi du flag C<G_KEEPERR> peuvent
également entraîner cet avertissement. Voir I<perlcall/G_KEEPERR>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item In EBCDIC the v-string components cannot exceed 2147483647

(En EBCDIC les composants de v-chaînes ne peuvent pas dépasser
2147483647) (F) Un erreur spécifique à l'EBCDIC. De manière interne,
les v-chaînes sont stockées comme des valeurs Unicode, et encodées en
EBCDIC avec UTF-EBCDIC. L'encodage UTF-EBCDIC est limité à des
valeurs ne dépassant pas 2147483647 (0x7FFFFFFF).

#endif
=item Insecure dependency in %s

(Dépendance non sécurisée dans I<%s>) (F) Vous avez essayé de faire
quelque chose que le mécanisme de marquage des variables n'a pas
apprécié. Ce mécanisme de marquage est activé quand vous exécutez un
script setuid ou setgid, ou lorsque vous spécifiez B<-T> pour
l'activer explicitement. Le mécanisme de marquage étiquette toutes
les données dérivées directement ou indirectement de l'utilisateur,
qui est considéré indigne de votre confiance. Si l'une de ces données
est utilisée dans une opération « dangereuse », vous obtenez cette
erreur.  Cf. L<perlsec> pour plus de renseignements.

=item Insecure directory in %s

(Répertoire non sécurisé dans I<%s>) (F) Vous ne pouvez utiliser
C<system>, C<exec> ou un pipe ouvert vers un script setuid ou setgid
si C<$ENV{PATH}> contient un répertoire qui a les droits en écriture
pour tout le monde. Cf. L<perlsec>.

#if defined(perldiag580) or defined(perldiag573)
=item Insecure $ENV{%s} while running %s

(C<$ENV{>I<%s>C<}> non sécurisé alors que I<%s> est en train de
tourner) (F) Vous ne pouvez utilisez C<system>, C<exec> ou un pipe
ouvert vers un script setuid ou setgid si C<$ENV{PATH}>, C<$ENV{IFS}>,
C<$ENV{CDPATH}>, C<$ENV{ENV}> ou C<$ENV{BASH_ENV}> sont dérivés de
données fournies (ou potentiellement fournies) par l'utilisateur. Le
script doit positionner le chemin à une valeur connue, en utilisant
une donnée digne de confiance. Cf. L<perlsec>.

#endif
#if defined(perldiag560)
=item Insecure $ENV{%s} while running %s

(C<$ENV{>I<%s>C<}> non sécurisé alors que I<%s> est en train de
tourner) (F) Vous ne pouvez utilisez C<system>, C<exec> ou un pipe
ouvert vers un script setuid ou setgid si C<$ENV{PATH}>,
C<$ENV{IFS}>, C<$ENV{CDPATH}>, C<$ENV{ENV}> ou C<$ENV{BASH_ENV}> sont
dérivés de données fournies (ou potentiellement fournies) par
l'utilisateur. Le script doit positionner le chemin à une valeur
connue, en utilisant une donnée digne de confiance. 

#endif
#if defined(perldiag560)
=item In string, @%s now must be written as \@%s

(Dans une chaîne, C<@>I<%s> doit maintenant s'écrire C<\@>I<%s>) (F)
Perl essayait auparavant de deviner si vous vouliez un tableau
interpolé ou un C<@> littéral. Il faisait ceci lorsque la chaîne
était utilisée la première fois pendant l'exécution. Les chaînes sont
maintenant analysées à la compilation et les instances ambiguës de
C<@> doivent être éclaircies, soit en préfixant par un antislash pour
indiquer qu'il s'agit d'un littéral, soit en déclarant (ou en
utilisant) le tableau dans le programme avant la chaîne
(lexicalement). (Un jour un C<@> sans antislash sera simplement
interprété comme une interpolation d'un tableau.) 

#endif
#if defined(perldiag560)
=item Integer overflow in %s number

(Dépassement d'entier dans le nombre I<%s>) (W overflow) Le nombre
hexadécimal, octal ou binaire que vous avez spécifié soit comme
littéral, soit comme argument de C<hex> ou C<oct> est trop grand pour
votre architecture. Sur les machines 32-bits ,les plus grands nombres
hexadécimaux, octaux ou binaires représentables sans dépassement sont
0xFFFFFFFF, 037777777777 et 0b11111111111111111111111111111111,
respectivement. Remarquez que Perl élève de manière transparente tous
les nombres vers une représentation interne en virgule flottante ---
sujette à des erreurs de perte de précision dans les opération
ultérieures. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Integer overflow in %s number

(Dépassement d'entier dans le nombre I<%s>) (W overflow) Le nombre
hexadécimal, octal ou binaire que vous avez spécifié soit comme
littéral, soit comme argument de C<hex> ou C<oct> est trop grand pour
votre architecture et a été converti en nombre flottant. Sur les
machines 32-bits ,les plus grands nombres hexadécimaux, octaux ou
binaires représentables sans dépassement sont 0xFFFFFFFF, 037777777777
et 0b11111111111111111111111111111111, respectivement. Remarquez que
Perl élève de manière transparente tous les nombres vers une
représentation interne en virgule flottante --- sujette à des erreurs
de perte de précision dans les opération ultérieures.

#endif
#if defined(perldiag561)
=item Internal disaster before << HERE in regex m/%s/

(Désastre interne dans une expression régulière) (P) Quelque chose
s'est très mal passé dans l'analyseur d'expressions régulières. La
mention « << HERE » indique l'endroit où le problème a été constaté.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Internal disaster in regex; marked by <-- HERE in m/%s/

(Désastre interne dans une expression régulière) (P) Quelque chose
s'est très mal passé dans l'analyseur d'expressions régulières. La
mention « <-- HERE » indique l'endroit où le problème a été constaté.

#endif
#if defined(perldiag560)
=item internal disaster in regexp

(Désastre interne dans une expression régulière) (P) Quelque chose
s'est très mal passé dans l'analyseur d'expressions régulières. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Internal inconsistency in tracking vforks

(Incohérence interne dans la recherche des C<vfork>) (S) Il s'agit
d'un avertissement spécifique à VMS. Perl garde une trace du nombre
de fois où vous avez appelé C<fork> et C<exec>, pour déterminer si
l'appel courant à C<exec> devrait affecter le script en cours ou un
sous-processus (Voir « exec LIST » dans I<perlvms>(1)). De toute
façon, ce compte est devenu perturbé, Perl fait donc une supposition
et traite ce C<exec> comme une requête pour terminer le script Perl
et exécuter la commande spécifiée. 

#endif
#if defined(perldiag560)
=item Internal inconsistency in tracking vforks

(Incohérence interne dans la recherche des C<vfork>s) (S) Il s'agit
d'un avertissement spécifique à VMS. Perl garde une trace du nombre
de fois où vous avez appelé C<fork> et C<exec>, pour déterminer si
l'appel courant à C<exec> devrait affecter le script en cours ou un
sous-processus (Voir « exec LIST » dans I<perlvms>(1)). De toute
façon, ce compte est devenu perturbé, Perl fait donc une supposition
et traite ce C<exec> comme une requête pour terminer le script Perl
et exécuter la commande spécifiée. 

#endif
#if defined(perldiag561)
=item Internal urp before << HERE in regex m/%s/

(Gloups interne dans une expression régulière) (P) Quelque chose a
très mal tourné dans l'analyseur d'expressions régulières. La mention
« << HERE » indique l'endroit où le problème a été constaté.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Internal urp in regex; marked by <-- HERE in m/%s/

(Gloups interne dans une expression régulière) (P) Quelque chose a
très mal tourné dans l'analyseur d'expressions régulières. La mention
« <-- HERE » indique l'endroit où le problème a été constaté.

#endif
#if defined(perldiag560)
=item internal urp in regexp at /%s/

(gloups interne dans une expression régulière) (P) Quelque chose a
très mal tourné dans l'analyseur d'expressions régulières. 

#endif
=item %s (...) interpreted as function

(I<%s> C<(...)> interprété comme une fonction) (W syntax) Vous avez
dérogé à la règle qui dit que tout opérateur de liste suivi par des
parenthèses devient une fonction prenant comme arguments tous les
opérateurs de listes trouvé entre les parenthèses. 
Cf. L<perlop/Terms and List Operators (Leftward)>.

=item Invalid %s attribute: %s

(Attribut I<%s> invalide : I<%s>) (F) L'attribut indiqué pour un
sous-programme ou une variable n'a pas été reconnu par Perl ou par un
gestionnaire fourni par l'utilisateur. Cf. L<attributes>.

=item Invalid %s attributes: %s

(Attributs I<%s> invalides : I<%s>) (F) Les attributs indiqués pour un
sous-programme ou une variable n'ont pas été reconnus par Perl ou par
un gestionnaire fourni par l'utilisateur. Cf. L<attributes>.

=item Invalid conversion in %s: "%s"

(Conversion invalide dans I<%s> : « I<%s> ») (W printf) Perl ne
comprend pas le format de conversion donné. Cf. L<perlfunc/sprintf>.

#if defined(perldiag580) or defined(perldiag573)
=item Invalid [] range "%s" in regex; marked by <-- HERE in m/%s/

(Intervalle C<[]> « I<%s> » invalide dans l'expression régulière) (F)
L'intervalle spécifié dans une classe de caractères a un caractère de
début supérieur au caractère de fin. Une possibilité est que vous avez
oublié les C<{}> dans le C<\x{}> de la fin. Sans accolades, C<\x> est
limité à C<ff>. La mention « <-- HERE » indique l'endroit où le
problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item invalid [] range "%s" in regexp

(Intervalle C<[]> « I<%s> » invalide dans l'expression régulière) (F)
L'intervalle spécifié dans une classe de caractères a un caractère de
début supérieur au caractère de fin. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Invalid [] range "%s" in transliteration operator

(Intervalle C<[]> « I<%s> » invalide dans l'opérateur de translation)
(F) L'intervalle spécifié dans l'opérateur C<tr///> ou C<y///> a un caractère de
début supérieur au caractère de fin. Cf. L<perlop>.

#endif
=item Invalid separator character %s in attribute list

(Caractère de séparation I<%s> invalide dans la liste d'attributs) (F)
Quelque chose d'autre qu'un deux-points ou qu'un espacement a été
détecté entre les éléments d'une liste d'attributs. Si l'attribut
précédent avait une liste de paramètres entre parenthèses, peut-être
que cette liste s'est terminée trop tôt. Cf. L<attributes>.

=item Invalid type in pack: '%s'

(Type invalide dans C<pack> : 'I<%s>') (F) Le caractère donné n'est
pas un type d'empaquetage valide. Cf. L<perlfunc/pack>.

(W pack) Le caractère donné n'est pas un type d'empaquetage valide
mais l'habitude était de l'ignorer silencieusement.

=item Invalid type in unpack: '%s'

(Type invalide dans C<unpack> : 'I<%s>') (F) Le caractère donné n'est
pas un type de dépaquetage valide. Cf. L<perlfunc/unpack>.

(W unpack) Le caractère donné n'est pas un type de dépaquetage valide
mais l'habitude était de l'ignorer silencieusement.

=item ioctl is not implemented

(C<ioctl> n'est pas implémenté) (F) Votre machine n'implémente
apparemment pas C<ioctl>, ce qui est quelque peu surprenant de la part
d'une machine qui supporte le C.

#if defined(perldiag580) or defined(perldiag573)
=item ioctl() on unopened %s

(C<ioctl> sur %s non ouvert) (W unopened) Vous avez tenté un C<ioctl> sur
un handle de fichier qui n'a jamais été ouvert. Vérifiez la logique de votre
programme et le nombre d'arguments.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item IO::Socket::atmark not implemented on this architecture

(C<IO::Socket::atmark> n'est pas implementé sur cette architecture)
(F) Votre machine n'implémente pas la fonction C<sockatmark()>, que ce
soit par un appel système ou par un appel à C<ioctl> (C<SIOCATMARK>).

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item `%s' is not a code reference

(« I<%s> » n'est pas une référence de code) (W overload) Le deuxième
(ou quatrième, ou sixième...) argument de C<overload::constant> doit
être une référence de code. Soit un sous-programme anonyme, soit
la référence à un sous-programme.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item `%s' is not an overloadable type

(« I<%s> » n'est pas un type surchargeable) (W overload) Vous avez essayé
de surcharger un type constant, mais le paquetage C<overload> ne le connaît pas.

#endif
=item junk on end of regexp

(Déchets à la fin de l'expression régulière) (P) L'analyseur
d'expressions régulières s'est embrouillé. 

=item Label not found for "last %s"

(Étiquette introuvable pour « C<last> I<%s> ») (F) Vous avez nommé
une boucle pour en sortir mais vous n'êtes pas actuellement dans une
boucle de ce nom, même si vous comptez d'où vous avez été appelé. 
Cf. L<perlfunc/last>.

=item Label not found for "next %s"

(Étiquette introuvable pour « C<next> I<%s> ») (F) Vous avez nommé une
boucle pour effectuer l'itération suivante mais vous n'êtes pas
actuellement dans une boucle de ce nom, même si vous comptez d'où vous
avez été appelé. Cf. L<perlfunc/next>.

=item Label not found for "redo %s"

(Étiquette introuvable pour « C<redo> I<%s> ») (F) Vous avez nommé une
boucle pour recommencer l'itération en cours mais vous n'êtes pas
actuellement dans une boucle de ce nom, même si vous comptez d'où vous
avez été appelé. Cf. L<perlfunc/redo>.

=item leaving effective %s failed

(la sortie de I<%s> effectif a échoué) (F) Alors que le pragma C<use
filetest> était actif, l'échange entre les UID ou les GID réels et
effectifs a échoué. 

#if defined(perldiag580) or defined(perldiag573)
=item listen() on closed socket %s

(C<listen()> sur une socket fermée I<%s>) (W closed) Vous avez essayé
de faire un C<listen> sur une socket fermée. Peut-être avez-vous
oublié de vérifier la valeur renvoyée par votre appel à C<socket> ? 
Cf. L<perlfunc/listen>.

#endif
#if defined(perldiag560)
=item listen() on closed socket %s

(C<listen()> sur une socket fermée I<%s>) (W closed) Vous avez essayé
de faire un C<listen> sur une socket fermée. Peut-être avez-vous
oublié de vérifier la valeur renvoyée par votre appel à C<socket> ? 

#endif
#if defined(perldiag561)
=item Lookbehind longer than %d not implemented at {#} mark in regex %s

(Les « rétro-visions » de plus de I<%d> caractères ne sont pas
implémentées dans les expressions régulières) (F) Il existe
actuellement une limite à la longueur des chaînes que l'on peut
traiter dans une assertion de « rétro-vision » (lookbehind).

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Lookbehind longer than %d not implemented in regex;

marked by <-- HERE in m/%s/

(Les « rétro-visions » de plus de I<%d> caractères ne sont pas
implémentées dans les expressions régulières) (F) Il existe
actuellement une limite à la longueur des chaînes que l'on peut
traiter dans une assertion de « rétro-vision » (lookbehind). Cette
restriction pourrait être levée dans une version ultérieure. La
mention « <-- HERE » indique l'endroit où le problème a été constaté.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item lstat() on filehandle %s

(C<lstat> sur un handle de fichier I<%s>) (W io) Vous avez essayé de
faire un C<lstat> sur un handle de fichier. Qu'est-ce que vous vouliez
faire, au juste ? C<lstat> n'a de sens que sur un nom de fichier (à la
place, Perl a effectué un C<fstat> sur le handle de fichier).

#endif
=item Lvalue subs returning %s not implemented yet

(Sous-programmes en tant que lvalue retournant I<%s> pas encore
implémentés) (F) À cause de limitations dans l'implémentation
actuelle, les valeurs de tableaux et de hachages ne peuvent pas être
renvoyées dans un contexte de lvalue. Cf. L<perlsub/"Lvalue
subroutines">.

=item Malformed PERLLIB_PREFIX

(C<PERLLIB_PREFIX> malformée) (F) Il s'agit d'une erreur spécifique à
OS/2. C<PERLLIB_PREFIX> doit être de la forme :

  prefixe1;prefixe2

ou :

  prefixe1 prefixe2

avec I<prefixe1> et I<prefixe2> non vides. Si I<prefixe1> est en fait
le préfixe d'un chemin de recherche de bibliothèque interne, on lui
substitue I<prefixe2>. L'erreur peut survenir si les composants ne
sont pas trouvés ou s'ils sont trop longs. Voir C<PERLLIB_PREFIX>
dans le fichier I<README.os2> inclus dans la distribution de Perl.

#if defined(perldiag580) or defined(perldiag573)
=item Malformed prototype for %s: %s

(Prototype pour I<%s> mal formé : I<%s>) (F) Vous avez essayé d'utiliser une
fonction avec un prototype mal formé. Au moment de la compilation, Perl effectue
une brève vérification des prototypes de fonction pour détecter des erreurs
évidentes comme des caractères invalides. Une vérification plus complète a lieu
lorsque la fonction est appelée.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Malformed UTF-8 character (%s)

(Caractère UTF-8 mal formé (I<%s>)) Perl a détecté quelque chose qui ne 
respecte pas les règles d'encodage UTF-8.

#endif
#if defined(perldiag580)
=item Malformed UTF-8 character (%s)

Perl detected something that didn't comply with UTF-8 encoding rules.

One possible cause is that you read in data that you thought to be in
UTF-8 but it wasn't (it was for example legacy 8-bit data).  Another
possibility is careless use of utf8::upgrade().

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Malformed UTF-16 surrogate

(Caractère de remplacement UTF-16 mal formé) Perl croyait être en train de lire
une donnée encodée en UTF-16, mais il est tombé sur une séquence de remplacement
Unicode mal formée.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item %s matches null string many times

(I<%s> correspond trop de fois à la chaîne vide) (W regexp) Le motif
que vous avez spécifié rentrerait dans une boucle infinie si le
moteur d'expressions régulières ne contrôlait pas cela. 

#endif
#if defined(perldiag573)
=item %s matches null string many times in regex;

marked by <-- HERE in m/%s/

(I<%s> correspond trop de fois à la chaîne vide) (W regexp) Le motif
que vous avez spécifié rentrerait dans une boucle infinie si le
moteur d'expressions régulières ne contrôlait pas cela. La mention
« <-- HERE » indique l'endroit où le problème a été constaté.
Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item "%s" may clash with future reserved word

(« I<%s> » risque d'entrer en conflit avec un futur mot réservé) (W)
Cet avertissement peut être dû à l'exécution d'un script perl5 par
un interpréteur perl4, surtout si le mot mis en cause est « C<use> »
ou « C<my> ».

#endif
=item % may only be used in unpack

(C<%> ne peut être utilisé que dans C<unpack>) (F) Vous ne pouvez pas
empaqueter une chaîne avec C<pack> en fournissant une somme de
contrôle car le traitement de cette dernière fait perdre de
l'information et vous ne pouvez pas revenir en arrière. 
Cf. L<perlfunc/unpack>.

=item Method for operation %s not found in package %s during blessing

(La méthode pour l'opération I<%s> n'a pas été trouvée dans le
paquetage I<%s> durant la consécration avec C<bless>) (F) Une
tentative a été effectuée pour spécifier une entrée dans une table de
surcharge qui ne peut être résolue par un sous-programme valide. 
Cf. L<overload>.

=item Method %s not permitted

(Méthode I<%s> interdite) Voir C<Server error>. 

=item Might be a runaway multi-line %s string starting on line %d

(I<%s> pourrait être une chaîne galopant sur plusieurs lignes,
débutant à la ligne I<%d>) (S) Une suggestion indiquant que l'erreur
précédente peut avoir été causée par un séparateur manquant dans une
chaîne ou un motif car la chaîne se finissait éventuellement plus tôt
sur la ligne courante. 

#if defined(perldiag561) or defined(perldiag560)
=item Misplaced _ in number

(C<_> mal placé dans un nombre) (W syntax) Un caractère souligné dans
une constante décimale n'était pas sur une limite de 3 chiffres. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Misplaced _ in number

(C<_> mal placé dans un nombre) (W syntax) Un caractère souligné dans
une constante décimale n'était pas entre deux chiffres. 

#endif
=item Missing %sbrace%s on \N{}

(I<%s>accoladesI<%s> manquantes sur C<\N{}>) (F) Vous avez employé la
mauvaise syntaxe de nom de caractère littéral C<\N{nom_caractere}> à
l'intérieur d'un contexte de guillemets. 

=item Missing comma after first argument to %s function

(Virgule manquante après le premier argument de la fonction I<%s>)
(F) Alors que certaines fonctions vous permettent de spécifier un
handle de fichier ou un « objet indirect » avant la liste
d'arguments, celle-ci n'en fait pas partie. 

=item Missing command in piped open

(Commande manquante dans un C<open> avec un pipe) (W pipe) Vous avez
utilisé la construction C<open(HF, "| commande")> ou C<open(HF,
"commande |")> mais il manquait la commande ou alors elle était vide. 

=item Missing name in "my sub"

(Nom manquant dans « C<my sub> ») (F) La syntaxe réservée pour les
sous-programmes de portée lexicale exige qu'ils aient un nom par
lequel on puisse les trouver. 

=item Missing $ on loop variable

(C<$> manquant dans un variable de boucle) (F) Apparemment, vous avez
programmé en I<csh> un peu trop longtemps. Les variables en Perl sont
toujours précédées du C<$>, au contraire des shells, où cela peut
varier d'une ligne à l'autre. 

=item (Missing operator before %s?)

(Opérateur manquant avant I<%s> ?) (S) Il s'agit d'une supposition
donnée en complément du message « I<%s> C<found where operator
expected> ». Souvent l'opérateur manquant est une virgule. 

#if defined(perldiag580) or defined(perldiag573)
=item Missing right brace on %s

(Accolade fermante absente dans I<%s>) (F) L'accolade fermante est
absente d'une construction C<\p{...}> ou C<\P{...}>.

#endif
=item Missing right curly or square bracket

(Accolade fermante ou crochet fermant manquant) (F) L'analyseur
lexical a compté plus d'accolades ouvrantes ou de crochets ouvrants
que d'accolades fermantes ou de crochets fermants. En règle générale,
vous trouverez le signe manquant à côté de l'endroit où vous venez
d'éditer. 

=item (Missing semicolon on previous line?)

(Point-virgule manquant sur la ligne précédente ?) (S) Il s'agit
d'une supposition donnée en complément du message « I<%s> C<found
where operator expected> ». Pour autant, n'ajoutez pas
systématiquement un point-virgule simplement parce que vous avez lu
ce message 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Modification of a read-only value attempted

(Tentative de modification d'une valeur en lecture seule) (F) Vous
avez essayé, directement ou indirectement, de changer la valeur d'une
constante. Vous ne pouvez pas, bien entendu, essayer de faire C<2 =
1> car le compilateur intercepte ceci. Mais une autre façon simple de
faire la même chose est : 

  sub mod { $_[0] = 1 }
  mod(2);

Un autre moyen serait d'affecter à C<substr> ce qui se trouve au-delà
de la fin de la chaîne.

Une troisième façon consiste à assigner une valeur à la variable d'un
C<foreach>, lorsque cette variable est l'alias d'une valeur constante.

        $x = 1;
        foreach my $n ($x, 2) {
            $n *= 2; # modifie $x, mais échoue en essayant de modifier 2
        }

#endif
#if defined(perldiag560)
=item Modification of a read-only value attempted

(Tentative de modification d'une valeur en lecture seule) (F) Vous
avez essayé, directement ou indirectement, de changer la valeur d'une
constante. Vous ne pouvez pas, bien entendu, essayer de faire C<2 =
1> car le compilateur intercepte ceci. Mais une autre façon simple de
faire la même chose est : 

  sub mod { $_[0] = 1 }
  mod(2);

Un autre moyen serait d'affecter à C<substr> ce qui se trouve au-delà
de la fin de la chaîne.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Modification of non-creatable array value attempted, %s

(Tentative de modification d'une valeur de impossible à créer, 
I<%s>) (F) Vous avez essayé de faire naître une valeur de tableau et
l'indice était probablement négatif, même en comptant à rebours
depuis de la fin du tableau. 

#endif
#if defined(perldiag560)
=item Modification of non-creatable array value attempted, subscript %d

(Tentative de modification d'une valeur de impossible à créer, indice
I<%d>) (F) Vous avez essayé de faire naître une valeur de tableau et
l'indice était probablement négatif, même en comptant à rebours
depuis de la fin du tableau. 

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Modification of non-creatable hash value attempted, %s

(Tentative de modification d'une valeur de hachage impossible à
créer, I<%s>) (P) Vous avez essayé de faire naître une
valeur de hachage et elle n'a pu être créée pour une raison
particulière. 

#endif
#if defined(perldiag560)
=item Modification of non-creatable hash value attempted, subscript "%s"

(Tentative de modification d'une valeur de hachage impossible à
créer, indice « I<%s> ») (P) Vous avez essayé de faire naître une
valeur de hachage et elle n'a pu être créée pour une raison
particulière. 

#endif
=item Module name must be constant

(Le nom de module doit être constant) (F) Seul un nom de module brut
est permis comme premier argument d'un C<use>. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Module name required with -%c option

(Nom de module obligatoire avec l'option C<->I<%c>) (F) Les options C<-M> et C<-m> 
signifient que Perl doit charger un module, mais vous avez oublié de
dire quel module. Reportez-vous à L<perlrun> pour plus de détails à propos de
C<-M> et de C<-m>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item More than one argument to open

(C<open> avec plus d'un argument) (F) Vous avez demandé à la fonction C<open>
d'ouvrir plusieurs fichiers. Cela peut se produire si vous ouvrez un pipe vers
une commande qui prend une liste d'arguments, mais que vous avez oublié de spécifier
une ouverture via un pipe. Cf. L<perlfunc/open> pour plus de détails.

#endif
=item msg%s not implemented

(msgI<%s> non implémenté) (F) Vous n'avez pas d'implémentation de
messages des IPC System V sur votre système. 

=item Multidimensional syntax %s not supported

(Syntaxe multidimensionnelle I<%s> non supportée) (W syntax) Les
tableaux multidimensionnels ne s'écrivent pas C<$truc[1,2,3]>. Ils
s'écrivent C<$truc[1][2][3]>, tout comme en C. 

=item / must be followed by a*, A* or Z*

(C</> doit être suivi par C<A*>, C<a*> ou C<Z*>) (F) Vous aviez un
canevas pour C<unpack> indiquant une chaîne d'une longueur sujette à
un compteur. Actuellement, les seules choses dont on peut compter la
longueur sont C<a*>, C<A*> ou C<Z*>. Cf. L<perlfunc/pack>.

=item / must be followed by a, A or Z

(C</> doit être suivi par C<A>, C<a> ou C<Z>) (F) Vous aviez un
canevas pour C<unpack> indiquant une chaîne d'une longueur sujette à
un compteur ; cette chaîne doit être suivie d'une des lettres C<a>,
C<A> ou C<Z> pour indiquer quelle sorte de chaîne doit être
dépaquetée. Cf. L<perlfunc/pack>.

=item / must follow a numeric type

(C</> doit suivre un type numérique) (F) Vous aviez un canevas pour
C<unpack> contenant un C<#>, mais celui-ci ne suivait pas l'une des
spécifications numériques d'C<unpack>. Cf. L<perlfunc/pack>.

=item "my sub" not yet implemented

(« C<my sub> » n'est pas encore implémenté) (F) Les sous-programmes
de portée lexicale ne sont pas encore implémentés. N'essayez pas
encore cela. 

=item "my" variable %s can't be in a package

(La variable « C<my> » I<%s> ne peut pas se trouver dans un
paquetage) (F) Les variables de portée lexicale ne se trouvent pas
dans un paquetage, et il ne sert donc à rien d'essayer d'en déclarer
une, préfixée d'un qualificateur de paquetage. Utilisez C<local> si
vous désirez donner une valeur locale à une variable de paquetage. 

=item Name "%s::%s" used only once: possible typo

(Nom « I<%s>C<::>I<%s> » utilisé une seule fois : faute de frappe
possible) (W once) Les fautes de frappe apparaissent fréquemment sous
la forme de noms de variable uniques. Si vous avez une bonne raison
pour cela, vous n'avez qu'à mentionner la variable à nouveau pour
supprimer ce message. La déclaration C<our> est destinée à cela. 

=item Negative length

(Longueur négative) (F) Vous avez essayé de faire une opération
C<read>/C<write>/C<send>/C<recv> avec un tampon de longueur plus
petite que 0. C'est difficile à imaginer. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Negative offset to vec in lvalue context

(Décalage négatif pour C<vec> en contexte lvalue) (F) Lorsque c<vec> est
appelé en contexte de lvalue, le deuxième argument doit être positif ou
nul.

#endif
#if defined(perldiag560)
=item nested *?+ in regexp

(C<*?+> imbriqué dans l'expression régulière) (F) Vous ne pouvez
quantifier un quantifiant sans faire intervenir de parenthèses. Donc
les choses comme C<**>, C<+*> ou C<?*> sont illégales. 

Remarquez cependant que les quantifiants de recherche de
correspondance minimum, C<*?>, C<+?>, et C<??> ressemblent à des des
quantifiants imbriqués mais ne le sont pas.

#endif
#if defined(perldiag561)
=item Nested quantifiers before << HERE in regex m/%s/

(C<*?+> imbriqué dans l'expression régulière) (F) Vous ne pouvez
quantifier un quantifiant sans faire intervenir de parenthèses. Donc
les choses comme C<**>, C<+*> ou C<?*> sont illégales. La mention 
« << HERE » indique l'endroit où le problème a été constaté.

Remarquez cependant que les quantifiants de recherche de
correspondance minimale, C<*?>, C<+?>, et C<??> ressemblent à des des
quantifiants imbriqués mais ne le sont pas. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Nested quantifiers in regex; marked by <-- HERE in m/%s/

(C<*?+> imbriqué dans l'expression régulière) (F) Vous ne pouvez
quantifier un quantifiant sans faire intervenir de parenthèses. Donc
les choses comme C<**>, C<+*> ou C<?*> sont illégales. La mention 
« <-- HERE » indique l'endroit où le problème a été constaté.

Remarquez cependant que les quantifiants de recherche de
correspondance minimale, C<*?>, C<+?>, et C<??> ressemblent à des des
quantifiants imbriqués mais ne le sont pas. Cf L<perlre>.

#endif
=item %s never introduced

(I<%s> n'a jamais été introduit) (S internal) Le symbole en question
a été déclaré mais sa portée s'est terminée avant qu'il soit possible
de s'en servir. 

#if defined(perldiag561) or defined(perldiag560)
=item No %s allowed while running setuid

(Pas de I<%s> autorisé alors que l'on tourne avec setuid) (F) Pour des
questions de sécurité, certaines opérations sont trop dangereuses pour
être exécutées, voire tentées, dans un script setuid ou setgid.
Généralement, il y existera bien un autre moyen pour faire ce que vous
voulez, c'est-à-dire que si ce moyen n'est pas sécurisé, il est au
moins sécurisable. Cf. L<perlsec>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item No %s allowed while running setuid

(Pas de I<%s> autorisé alors que l'on tourne avec setuid) (F) Pour des
questions de sécurité, certaines opérations sont trop dangereuses pour
être exécutées, voire tentées, dans un script setuid ou setgid.
Généralement, il y existe bien un autre moyen pour faire ce que vous
voulez, c'est-à-dire que si ce moyen n'est pas sécurisé, il est au
moins sécurisable. Cf. L<perlsec>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item No B<-e> allowed in setuid scripts

(Pas de B<-e> autorisé dans les scripts setuid) (F) Un script setuid
ne peut être spécifié par l'utilisateur. 

#endif
#if defined(perldiag560)
=item No comma allowed after %s

(Pas de virgule autorisée après I<%s>) (F) Lorsqu'un opérateur de
liste a un handle de fichier ou un « object indirect », il ne doit
pas y avoir une virgule ce premier argument et les arguments
suivants. Sinon, il serait juste interprété comme tout autre un
argument.

Une situation ténébreuse dans laquelle ce message se produit est
lorsque vous vous attendez à importer une constante dans votre espace
de noms avec C<use> ou C<import> mais qu'une telle importation ne
s'est pas produite. Vous auriez dû utiliser une liste d'importation
explicite des constantes que vous vous attendiez à voir. Une liste
d'importation explicite aurait probablement intercepté cette erreur
plus tôt. Ou peut-être s'agit-il seulement d'une erreur de frappe
dans le nom de la constante.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item No comma allowed after %s

(Pas de virgule autorisée après I<%s>) (F) Lorsqu'un opérateur de
liste a un handle de fichier ou un « object indirect », il ne doit
pas y avoir une virgule ce premier argument et le deuxième.
Sinon, il serait juste interprété comme un argument parmi tant d'autres.

Une situation ténébreuse dans laquelle ce message se produit est
lorsque vous vous attendez à importer une constante dans votre espace
de noms avec C<use> ou C<import> mais qu'une telle importation ne
s'est pas produite (le cas où votre système d'exploitation ne supporte
pas cette constante). Vous auriez dû utiliser une liste d'importation
explicite des constantes que vous vous attendiez à voir, reportez-vous
à L<perlfunc/use> et L<perlfunc/import>. Une liste d'importation
explicite aurait probablement intercepté cette erreur plus tôt, ce qui
n'aurait rien changé au fait que votre système d'exploitation ne
supporte pas cette constante. Ou peut-être s'agit-il seulement d'une
erreur de frappe dans le nom de la constante, soit dans la liste
fournie à C<use> ou C<import>, soit dans la ligne où la constante est
utilisée ?

#endif
=item No command into which to pipe on command line

(Pas de commande dans laquelle envoyer un pipe sur la ligne de
commande) (F) Il s'agit d'une erreur spécifique à VMS. Perl effectue
ses propres redirections dans la ligne de commande et a trouvé un
C<|> à la fin de la ligne de commande, il ne sait donc pas vers où
vous voulez rediriger avec un pipe la sortie de cette commande. 

=item No DB::DB routine defined

(Pas de routine C<DB::DB> de définie) (F) Le code en train
d'être exécuté a été compilé avec l'option B<-d> mais pour une raison
ou pour une autre le fichier I<perl5db.pl> (ou alors un fac-similé)
n'a pas défini de routine à appeler au début de chaque instruction.
Ce qui est étrange car le fichier aurait dû être chargé
automatiquement et n'a pas pu être analysé correctement. 

=item No dbm on this machine

(Pas de dbm sur cette machine) (P) Ceci est compté comme une erreur
interne ; chaque machine doit fournir dbm de nos jours car Perl est
livré avec SDBM. Cf. L<SDBM_File>.

=item No DBsub routine

(Pas de routine C<DBsub>) (F) Le code en train de s'exécuter a été
compilé avec l'option B<-d> mais pour une raison ou pour une autre le
fichier I<perl5db.pl> (ou alors un fac-similé) n'a pas défini de
routine C<DB::sub> à appeler au début de chaque appel de
sous-programme ordinaire. 

#if defined(perldiag560)
=item No -e allowed in setuid scripts

(pas de B<-e> autorisé dans les scripts setuid) (F) Un script setuid
ne peut être spécifié par l'utilisateur. 

#endif
=item No error file after 2> or 2>> on command line

(Pas de fichier d'erreur après C<< 2> >> ou C<< 2>> >> sur la ligne
de commande) (F) Il s'agit d'une erreur spécifique à VMS. Perl
effectue ses propres redirections dans la ligne de commande et y a
trouvé un C<< 2> >> ou un C<< 2>> >> mais sans trouver le nom du
fichier dans lequel écrire les données destinées à C<STDERR>. 

=item No input file after < on command line

(Pas de fichier d'entrée après C<< < >> sur la ligne de commande) (F)
Il s'agit d'une erreur spécifique à VMS. Perl effectue ses propres
redirections dans la ligne de commande et y a trouvé un C<< < >> mais
sans trouver le nom du fichier depuis lequel lire les données de
C<STDIN>. 

=item No #! line

(Pas de ligne C<#!>) (F) L'émulateur setuid exige que le script
possède une ligne valide de la forme C<#!> même sur les machines ne
supportant pas la construction C<#!>. 

=item "no" not allowed in expression

(« C<no> » n'est pas autorisé dans une expression) (F) Le mot-clef
C<no> est reconnu et exécuté à la compilation et il ne renvoie aucune
valeur utile. Cf. L<perlmod>.

#if defined(perldiag580) or defined(perldiag573)
=item No output file after > on command line

(Pas de fichier de sortie après C<< > >> sur la ligne
de commande) (F) Il s'agit d'une erreur spécifique à VMS. Perl
effectue ses propres redirections dans la ligne de commande et a
trouvé un C<< > >> isolé à la fin de la ligne de commande mais sans
savoir où vous vouliez rediriger C<STDOUT>. 

#endif
#if defined(perldiag560)
=item No output file after > on command line

(Pas de fichier de sortie après C<< 2> >> ou C<< 2>> >> sur la ligne
de commande) (F) Il s'agit d'une erreur spécifique à VMS. Perl
effectue ses propres redirections dans la ligne de commande et a
trouvé un C<< > >> isolé à la fin de la ligne de commande mais sans
savoir où vous vouliez redirigez C<STDOUT>. 

#endif
=item No output file after > or >> on command line

(Pas de fichier de sortie après C<< > >> ou C<< >> >> sur la ligne de
commande) (F) Il s'agit d'une erreur spécifique à VMS. Perl effectue
ses propres redirections dans la ligne de commande et y a trouvé un
C<< > >> ou un C<< >> >> mais sans trouver le nom du fichier dans
lequel écrire les données destinées à C<STDOUT>. 

=item No package name allowed for variable %s in "our"

(Pas de nom de paquetage autorisé pour la variable I<%s> dans 
« C<our> ») (F) Les noms de variable pleinement qualifiés ne sont pas
autorisés dans les déclarations C<our> car cela n'aurait pas beaucoup
de sens avec les sémantiques existantes. Une telle syntaxe est
réservée pour de futures extensions. 

=item No Perl script found in input

(Pas de script Perl trouvé en entrée) (F) Vous avez appelé I<perl -x>
mais aucune ligne n'est trouvée dans le fichier commençant par C<#!>
et contenant le mot « C<perl> ». 

=item No setregid available

(Pas de setregid de disponible) (F) I<Configure> n'a rien trouvé qui
ressemble à l'appel C<setregid> pour votre système. 

=item No setreuid available

(Pas de setreuid de disponible) (F) I<Configure> n'a rien trouvé qui
ressemble à l'appel C<setreuid> pour votre système. 

=item No space allowed after -%c

(Pas d'espace autorisé après B<->I<%c>) (F) L'argument de
l'option de la ligne de commande indiquée doit suivre immédiatement
l'option, sans qu'aucun espace n'intervienne. 

=item No %s specified for -%c

(Pas de I<%s> spécifié pour B<->I<%c>) (F) L'option de la
ligne de commande indiquée nécessite un argument obligatoire mais
vous n'en avez pas spécifié. 

#if defined(perldiag580) or defined(perldiag573)
=item No such class %s

(Aucune classe I<%s>) (F) Vous avez utilisé un qualifiant de classe dans
une déclaration « C<my> » ou « C<our> », mais cette classe n'existe pas
à ce point du programme.

#endif
=item No such pipe open

(Aucun pipe ouvert) (P) Il s'agit d'une erreur spécifique à VMS. La
routine interne C<my_pclose> a essayé de fermer un pipe qui n'avait
pas été ouvert. Ceci aurait dû être capturé plus tôt comme une
tentative de fermeture d'un handle de fichier non ouvert. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item No such pseudo-hash field "%s"

(Aucun champ de pseudo-hachage « I<%s> ») (F) Vous avez essayé
d'accéder à un tableau en tant que hachage mais le nom de champ
utilisé n'est pas défini. Le hachage à l'indice 0 doit faire
correspondre tous les noms de champs valides aux indices du tableau
pour que cela fonctionne. 

#endif
#if defined(perldiag560)
=item No such pseudohash field "%s"

(Aucun champ de pseudo-hachage « I<%s> ») (F) Vous avez essayé
d'accéder à un tableau en tant que hachage mais le nom de champ
utilisé n'est pas défini. Le hachage à l'indice 0 doit faire
correspondre tous les noms de champs valides aux indices du tableau
pour que cela fonctionne. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item No such pseudo-hash field "%s" in variable %s of type %s

(Aucun champ de pseudo-hachage « I<%s> » dans la variable I<%s> de
type I<%s>) (F) Vous avez essayé d'accéder à un champ d'une variable
typée mais le type ignore le nom du champ. Les noms de champ sont
recherchés dans le hachage C<%FIELDS> dans le paquetage du type à la
compilation. Le hachage C<%FIELDS> est généralement initialisé avec
le pragma C<fields>. 

#endif
#if defined(perldiag560)
=item No such pseudohash field "%s" in variable %s of type %s

(Aucun champ de pseudo-hachage « I<%s> » dans la variable I<%s> de
type I<%s>) (F) Vous avez essayé d'accéder à un champ d'une variable
typée mais le type ignore le nom du champ. Les noms de champ sont
recherchés dans le hachage C<%FIELDS> dans le paquetage du type à la
compilation. Le hachage C<%FIELDS> est généralement initialisé avec
le pragma C<fields>. 

#endif
=item No such signal: SIG%s

(Aucun signal: C<SIG>I<%s>) (W signal) Le nom de signal que vous avez
spécifié comme indice de C<%SIG> n'a pas été reconnu. Faites I<kill
-l> dans votre shell pour voir les noms de signaux valides sur votre
système. 

=item Not a CODE reference

(Non une référence de CODE) (F) Perl a essayé d'évaluer une référence
vers une valeur de code (c'est-à-dire un sous-programme) mais a
trouvé une référence vers quelque chose d'autre à la place. Vous
pouvez utiliser la fonction C<ref> pour trouver de quelle sorte de
référence il s'agissait exactement. 

=item Not a format reference

(Non une référence de format) (F) Nous ne sommes pas sûrs de la
manière dont vous vous arrangez pour générer une référence vers un
format anonyme, mais ce message indique que vous l'avez fait et que
cela n'existe pas. 

=item Not a GLOB reference

(Non une référence de GLOB) (F) Perl a essayé d'évaluer une référence
vers un « typeglob » (c'est-à-dire une entrée dans la table des
symboles ressemblant à C<*truc>) mais a trouvé une référence vers
quelque chose d'autre à la place. Vous pouvez utiliser la fonction
C<ref> pour trouver de quelle sorte de référence il s'agissait
exactement. Cf. L<perlref>.

=item Not a HASH reference

(Non une référence de HACHAGE) (F) Perl a essayé d'évaluer une
référence vers une valeur de hachage mais a trouvé une référence vers
quelque chose d'autre à la place. Vous pouvez utiliser la fonction
C<ref> pour trouver de quelle sorte de référence il s'agissait
exactement. Cf. L<perlref>.

#if defined(perldiag580) or defined(perldiag573)
=item %s not allowed in length fields

(I<%s> interdit dans un champ de longueur) (F) Le nombre dans un canevas de
C<(un)pack> peut être remplacé par C<[CANEVAS]> seulement si C<CANEVAS>
correspond toujours au même nombre d'octets empaquetés. Repensez votre
canevas.

#endif
=item Not an ARRAY reference

(Non une référence de TABLEAU) (F) Perl a essayé d'évaluer une
référence vers une valeur de tableau mais a trouvé une référence vers
quelque chose d'autre à la place. Vous pouvez utiliser la fonction
C<ref> pour trouver de quelle sorte de référence il s'agissait
exactement. Cf. L<perlref>.

=item Not a perl script

(Non un script perl) (F) L'émulateur setuid exige que le script
possède une ligne valide de la forme C<#!> même sur les machines ne
supportant pas la construction C<#!>. La ligne doit mentionner 
« C<perl> ». 

=item Not a SCALAR reference

(Non une référence de SCALAIRE) (F) Perl a essayé d'évaluer une
référence vers une valeur scalaire mais a trouvé une référence vers
quelque chose d'autre à la place. Vous pouvez utiliser la fonction
C<ref> pour trouver de quelle sorte de référence il s'agissait
exactement. Cf. L<perlref>.

=item Not a subroutine reference

(Non une référence de sous-programme) (F) Perl a essayé d'évaluer une
référence vers une valeur de code (c'est-à-dire un sous-programme)
mais a trouvé une référence vers quelque chose d'autre à la place.
Vous pouvez utiliser la fonction C<ref> pour trouver de quelle sorte
de référence il s'agissait exactement. Cf. aussi L<perlref>.

=item Not a subroutine reference in overload table

(Non une référence de sous-programme dans la table de surcharge) (F)
Une tentative a été faite pour spécifier une entrée dans une table de
surcharge qui ne pointe pas d'une façon ou d'une autre vers un
sous-programme valide. Cf. L<overload>.

=item Not enough arguments for %s

(Pas assez d'arguments pour I<%s>) (F) La fonction exige plus
d'arguments que vous n'en avez spécifiés. 

=item Not enough format arguments

(Pas assez d'arguments de format) (W syntax) Un format spécifiait
plus de champs d'images que la ligne suivante ne lui en a fournis. 
Cf. L<perlform>.

=item %s: not found

(I<%s> : introuvable ) (A) Vous avez lancé accidentellement votre
script avec le Bourne Shell au lieu de Perl. Vérifiez la ligne avec
C<#!> ou lancez vous-même votre script manuellement dans Perl avec
I<perl nom_script>. 

#if defined(perldiag560)
=item No UTC offset information; assuming local time is UTC

(Pas d'information sur le décalage UTC ; adopte UTC comme heure
locale) (S) Il s'agit d'un avertissement spécifique à VMS. Perl a été
incapable de trouver le décalage horaire pour l'heure locale, il a
donc supposé que l'heure locale du système et UTC étaient
équivalentes. SI ce n'est pas le cas, définissez le nom logique
C<SYS$TIMEZONE_DIFFERENTIAL> pour qu'il traduise le nombre de
secondes à ajouter à UTC afin d'obtenir l'heure locale. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item no UTC offset information; assuming local time is UTC

(Pas d'information sur le décalage UTC ; adopte UTC comme heure
locale) (S) Il s'agit d'un avertissement spécifique à VMS. Perl a été
incapable de trouver le décalage horaire pour l'heure locale, il a
donc supposé que l'heure locale du système et UTC étaient
équivalentes. Si ce n'est pas le cas, définissez le nom logique
C<SYS$TIMEZONE_DIFFERENTIAL> pour qu'il traduise le nombre de
secondes à ajouter à UTC afin d'obtenir l'heure locale. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Null filename used

(Nom de fichier vide utilisé) (F) Vous ne pouvez utiliser un nom de
fichier vide avec C<require>, notamment car sur beaucoup de machines
ceci signifie le répertoire courant ! Cf. L<perlfunc/require>.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Null filename used

(Nom de fichier vide utilisé) (F) Vous ne pouvez exiger un nom de
fichier vide, notamment car sur beaucoup de machines ceci signifie le
répertoire courant !  Cf. L<perlfunc/require>.

#endif
=item NULL OP IN RUN

(OP NUL DANS RUN) (P debugging) Une routine interne a appelé C<run>
avec un pointer de code d'opération (I<opcode>) nul. 

=item Null picture in formline

(Image vide dans C<formline>) (F) Le premier argument de C<formline>
doit être une spécification de format d'image valide. On a trouvé que
cet argument était vide, ce qui signifie probablement que vous lui
avez fourni une valeur non initialisée. Cf. L<perlform>.

#if defined(perldiag580) or defined(perldiag573)
=item Null realloc

(Réallocation nulle) (P) Une tentative a eu lieu pour réallouer le
pointeur C<NULL>. 

#endif
#if defined(perldiag560)
=item Null realloc

(réallocation nulle) (P) Une tentative a eu lieu pour réallouer le
pointeur C<NULL>. 

#endif
#if defined(perldiag560)
=item NULL regexp argument

(argument NUL dans l'expression régulière) (P) Les routines internes
de recherche de motifs ont tout explosé. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item NULL regexp argument

(Argument NUL dans l'expression régulière) (P) Les routines internes
de recherche de motifs ont tout explosé. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item NULL regexp parameter

(Paramètre NUL dans l'expression régulière) (P) Les routines internes
de recherche de motifs ont perdu la tête. 

#endif
#if defined(perldiag560)
=item NULL regexp parameter

(paramètre NUL dans l'expression régulière) (P) Les routines internes
de recherche de motifs ont perdu la tête. 

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Number too long

(Nombre trop long) (F) Perl limite la représentation des nombres
décimaux dans les programmes à environ 250 caractères. Vous avez
dépassé cette longueur. Les futures versions de Perl sont
susceptibles d'éliminer cette limitation arbitraire. En attendant,
essayez d'utiliser la notation scientifique (ex. C<1e6> au lieu de
C<1_000_000>). 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Number too long

(Nombre trop long) (F) Perl limite la représentation des nombres
décimaux dans les programmes à environ 250 caractères. Vous avez
dépassé cette longueur. Les versions futures de Perl sont
susceptibles d'éliminer cette limitation arbitraire. En attendant,
essayez d'utiliser la notation scientifique (ex. C<1e6> au lieu de
C<1_000_000>). 

#endif
=item Octal number in vector unsupported

(Nombre octal dans un vecteur non supporté) (F) Les nombres
commençant par un C<0> ne sont actuellement pas autorisés dans les
vecteurs. L'interprétation en octal de tels nombres sera peut-être
supportée dans une future version. 

#if defined(perldiag580) or defined(perldiag573)
=item Octal number > 037777777777 non-portable

(Nombre octal > C<0>37777777777, non portable) (W portable) Le nombre
octal que vous avez spécifié est plus grand que C<2**32-1> 
(4 294 967 295) et n'est donc pas portable d'un système à l'autre. 

Reportez-vous également à L<perlport> pour savoir comment écrire
du code portable.

#endif
#if defined(perldiag560)
=item Octal number > 037777777777 non-portable

(Nombre octal > C<0>37777777777, non portable) (W portable) Le nombre
octal que vous avez spécifié est plus grand que C<2**32-1> 
(4 294 967 295) et n'est donc pas portable d'un système à l'autre. 

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Odd number of arguments for overload::constant

(Nombre impair d'arguments pour C<overload::constant>) (W overload)
L'appel de  C<overload::constant> comporte un nombre impair d'arguments.
Ils devraient aller par paires.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Odd number of elements in anonymous hash

(Nombre impair d'éléments dans un hachage anonyme) (W misc) Vous avez
commis un impair en spécifiant un nombre impair d'éléments pour initialiser
un hachage, alors que les hachages contiennent des paires clef/valeur.

#endif
=item Odd number of elements in hash assignment

(Nombre impair d'élément dans une affectation de hachage) (W misc)
Vous avez spécifié un nombre impair d'éléments pour initialiser un
hachage, ce qui est un impair à la règle car un hachage consiste en des
paires clé/valeur. 

=item Offset outside string

(Décalage en dehors de la chaîne) (F) Vous avez essayé de faire une
opération C<read>/C<write>/C<send>/C<recv> avec un décalage pointant
en dehors du tampon. Ceci est difficile à imaginer. La seule
exception à cette règle est que faire un C<sysread> après un tampon
étendra ce tampon et remplira de zéros la nouvelle zone. 

#if defined(perldiag580) or defined(perldiag573)
=item %s() on unopened %s

(I<%s>C<()> sur I<%s> fermé) (W unopened) Une opération
d'entrée-sortie a été tentée sur un handle de fichier qui n'a jamais
été initialisé. Vous devez commencer pas appeler C<open>, C<sysopen>,
C<socket> ou un constructeur du paquetage C<FileHandle>.

#endif
#if defined(perldiag561)
=item %s() on unopened %s %s

(I<%s>C<()> sur I<%s> fermé I<%s>) (W unopened) Une opération
d'entrée-sortie a été tentée sur un handle de fichier qui n'a jamais
été initialisé. Vous devez commencer pas appeler C<open>, C<sysopen>,
C<socket> ou un constructeur du paquetage C<FileHandle>.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item -%s on unopened filehandle %s

(C<->I<%s> sur un handle de fichier fermé I<%s>) (W unopened) Vous avez essayé
d'appeler un opérateur de test de fichier sur un handle de fichier qui n'est
pas ouvert. Vérifier le déroulement de votre programme. Voyez aussi L<perlfunc/-X>.

#endif
=item oops: oopsAV

(gloups : gloupsAV) (S internal) Il s'agit d'un avertissement interne
que la grammaire est vérolée. 

=item oops: oopsHV

(gloups gloupsHV) (S internal) Il s'agit d'un avertissement interne
que la grammaire est vérolée. 

#if defined(perldiag560)
=item Operation "%s": no method found, %s

(Opération « I<%s> » : aucune méthode trouvée, I<%s>) (F) Une
tentative a été faite pour effectuer une opération de surcharge pour
laquelle aucun gestionnaire n'a été défini. Alors que certains
gestionnaires peuvent être auto-générés en termes d'autres
gestionnaires, il n'existe pas de gestionnaire par défaut pour
quelque opération que ce soit, à moins que la clé de surcharge
C<fallback> soit spécifiée comme étant vraie. Cf L<overload>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Operation `%s': no method found, %s

(Opération « I<%s> » : aucune méthode trouvée, I<%s>) (F) Une
tentative a été faite pour effectuer une opération de surcharge pour
laquelle aucun gestionnaire n'a été défini. Alors que certains
gestionnaires peuvent être auto-générés en termes d'autres
gestionnaires, il n'existe pas de gestionnaire par défaut pour
quelque opération que ce soit, à moins que la clé de surcharge
C<fallback> soit spécifiée comme étant vraie. Cf L<overload>.

#endif
=item Operator or semicolon missing before %s

(Opérateur ou point-virgule manquant avant I<%s>) (S ambiguous) Vous
avez utilisé une variable ou un appel de sous-programme là où
l'analyseur syntaxique s'attendait à trouver un opérateur.
L'analyseur a considéré que vous pensiez vraiment utiliser un
opérateur mais cela est fortement susceptible de s'avérer incorrect.
Par exemple, si vous écrivez accidentellement C<*truc *truc>, cela
sera interprété comme si vous aviez écrit C<*truc * 'truc'>. 

=item "our" variable %s redeclared

(La variable « C<our> » I<%s> est redéclarée) (W misc) Il semble que
vous avez déjà déclaré la même variable globale auparavant dans la
même portée lexicale. 

=item Out of memory!

(Dépassement de mémoire !) (X) La fonction interne de Perl C<malloc>
a renvoyé 0, ce qui indique que la mémoire restante (ou la mémoire
virtuelle) n'a pas suffit à satisfaire la requête. Perl n'a pas
d'autre option que de sortir immédiatement. 

=item Out of memory during "large" request for %s

(Dépassement de mémoire pendant une requête « large » pour I<%s>) (F)
La fonction C<malloc> a renvoyé 0, ce qui indique que la mémoire
restante (ou la mémoire virtuelle) n'a pas suffit à satisfaire la
requête. Cependant, la requête a été jugée assez large (par défaut
64K à la compilation), la possibilité de sortir en capturant cette
erreur est donc permise. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Out of memory during request for %s

(Dépassement de mémoire pendant une requête pour I<%s>) (X|F) La
fonction C<malloc> a renvoyé 0, ce qui indique que la mémoire
restante (ou la mémoire virtuelle) n'a pas suffit à satisfaire la
requête.

La requête a été jugée faible, la possibilité de la capturer est donc
dépendante de la façon dont Perl a été compilé. Par défaut, elle ne
peut être capturée. Cependant, s'il a été compilé à cet effet, Perl
peut utiliser le contenu de C<$^M> comme une zone d'urgence après
être sorti par C<die> avec ce message. Dans ce cas l'erreur peut-être
capturée I<une seule fois>, et le message d'erreur indiquera le fichier
et la ligne où s'est produite la requête qui a échoué.

#endif
#if defined(perldiag560)
=item Out of memory during request for %s

(Dépassement de mémoire pendant une requête pour I<%s>) (X|F) La
fonction C<malloc> a renvoyé 0, ce qui indique que la mémoire
restante (ou la mémoire virtuelle) n'a pas suffit à satisfaire la
requête.

La requête a été jugée faible, la possibilité de la capturer est donc
dépendante de la façon dont Perl a été compilé. Par défaut, elle ne
peut être capturée. Cependant, s'il a été compilé à cet effet, Perl
peut utiliser le contenu de C<$^M> comme une zone d'urgence après
être sorti par C<die> avec ce message. Dans ce cas l'erreur peut-être
capturée I<une seule fois>.

#endif
=item Out of memory during ridiculously large request

(Dépassement de mémoire pendant un requête ridiculement large) (F)
Vous ne pouvez allouer plus de C<2**31+>« epsilon » octets. Cette
erreur est généralement causée par une faute de frappe dans le
programme Perl (ex. C<$tab[time]> au lieu de C<$tab[$time]>). 

=item Out of memory for yacc stack

(Dépassement de mémoire pour la pile de yacc) (F) L'analyseur
syntaxique I<yacc> a voulu agrandir sa pile pour qu'il puisse
continuer son analyse mais C<realloc> n'a pas voulu lui donner plus
de mémoire, virtuelle ou autre. 

=item @ outside of string

(C<@> à l'extérieur de la chaîne) (F) Vous aviez un canevas empaqueté
qui spécifiait une position absolue en dehors de la chaîne à
dépaqueter. Cf. L<perlfunc/pack>. 

=item %s package attribute may clash with future reserved word: %s

(L'attribut de paquetage I<%s> risque de rentrer en conflit avec le
mot I<%s> réservé pour une utilisation ultérieure) (W reserved) Un
nom d'attribut en minuscules géré par un paquetage spécifique a été
utilisé. Ce mot pourrait avoir un sens pour Perl un jour, même si ce
n'est pas encore le cas. Peut-être devriez-vous employer à la place
un nom mélangeant des majuscules et des minuscules. Cf. L<attributes>.

=item page overflow

(Dépassement de page mémoire) (W io) Un seul appel à C<write> a
produit plus de lignes que ne peut en contenir une page. 
Cf. L<perlform>.

=item panic: %s

(panique : I<%s>) (P) Une erreur interne. 

=item panic: ck_grep

(panique : C<ck_grep>) (P) Le programme a échoué sur un test de
cohérence interne en essayant de compiler un C<grep>. 

=item panic: ck_split

(panique : C<ck_split>) (P) Le programme a échoué sur un test de
cohérence interne en essayant de compiler un C<split>. 

=item panic: corrupt saved stack index

(panique : index de la pile de sauvegarde corrompu) (P) On a demandé
à la pile de sauvegarde de restaurer plus de valeurs localisées qu'il
n'en existe. 

=item panic: del_backref

(panique : référence arrière supprimée) (P) Le programme a échoué sur
un test de cohérence interne en essayant de réinitialiser une
référence lâche (I<weak reference>). 

=item panic: die %s

(panique : C<die> I<%s>) (P) Nous avons passé l'élément du dessus de
la pile de contexte à un contexte d'C<eval> pour découvrir alors que
l'on n'était pas dans un contexte d'C<eval>. 

#if defined(perldiag560)
=item panic: do_match

(panique : C<do_match>) (P) La routine interne C<pp_match> a été
appelée avec des données opérationnelles invalides. 

#endif
#if defined(perldiag560)
=item panic: do_split

(panique : C<do_split>) (P) Quelque chose de terrible s'est mal passé
lors de la préparation pour un C<split>. 

#endif
=item panic: do_subst

(panique : C<do_subst>) (P) La routine interne C<pp_subst> a été
appelée avec des données opérationnelles invalides. 

#if defined(perldiag560)
=item panic: do_trans

(panique : C<do_trans>) (P) La routine interne C<do_trans> a été
appelée avec des données opérationnelles invalides. 

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item panic: do_trans_%s

(panique : C<do_trans_>I<%s>) (P) Les routines internes C<do_trans> ont été
appelées avec des données opérationnelles invalides. 

#endif
=item panic: frexp

(panique : C<frexp>) (P) La fonction de la bibliothèque C<frexp> a
échoué, rendant le C<printf("%f")> impossible. 

=item panic: goto

(panique : C<goto>) (P) Nous avons passé l'élément du dessus de la
pile à un contexte avec l'étiquette spécifiée et découvert ensuite
qu'il ne s'agissait pas d'un contexte que nous savions joindre par un
C<goto>. 

=item panic: INTERPCASEMOD

(panique : C<INTERPCASEMOD>) (P) L'analyseur lexical s'est retrouvé
dans un mauvais état à un modificateur de casse
(majuscule/minuscule). 

=item panic: INTERPCONCAT

(panique : C<INTERPCONCAT>) (P) L'analyseur lexical s'est retrouvé
dans un mauvais état en analysant une chaîne de caractères avec des
parenthèses. 

=item panic: kid popen errno read

(panique : lecture du numéro d'erreur dans le C<popen> d'un fils) (F)
Un fils issu d'un C<fork> a renvoyé un message incompréhensible à
propose de son numéro d'erreur. 

=item panic: last

(panique : C<last>) (P) Nous avons passé l'élément du dessus de la
pile à un contexte de bloc et découvert par la suite que ce n'était
pas un contexte de bloc. 

=item panic: leave_scope clearsv

(panique : C<clearsv> dans la sortie de la portée) (P) Une variable
lexicale modifiable est maintenant en lecture seule dans le bloc pour
une raison ou pour une autre. 

=item panic: leave_scope inconsistency

(panique : sortie de la portée incohérente) (P) La pile de sauvegarde
n'est sûrement plus synchronisée. Du moins, il y avait un type
C<enum> invalide à son sommet. 

=item panic: magic_killbackrefs

(panique : suppression magique de toutes les références arrières) (P)
Le programme a échoué sur un test de cohérence interne en essayant de
réinitialiser toutes les références lâches (I<N.d.T.> : I<weak
references>) vers un objet. 

=item panic: malloc

(panique : C<malloc>) (P) Quelque chose a demandé un nombre négatif
d'octets à C<malloc>. 

=item panic: mapstart

(panique : C<mapstart>) (P) Le compilateur s'est embrouillé avec la
fonction C<map>. 

=item panic: null array

(panique : tableau nul) (P) On a passé à l'une des routines internes
pour les tableaux un pointeur d'AV nul. 

=item panic: pad_alloc

(panique : C<pad_alloc>) (P) Le compilateur ne sait plus quelle
mémoire de travail (I<scratchpad>) il utilisait pour allouer et 
libérer les valeurs temporaires et lexicales. 

=item panic: pad_free curpad

(panique : C<pad_free curpad>) (P) Le compilateur ne sait plus quelle
mémoire de travail (I<scratchpad>) il utilisait pour allouer et 
libérer les valeurs temporaires et lexicales. 

=item panic: pad_free po

(panique : C<pad_free po>) (P) Un décalage incorrect dans la mémoire
de travail (I<scratchpad>) a été détecté en interne. 

=item panic: pad_reset curpad

(panique : C<pad_reset curpad>) (P) Le compilateur ne sait plus
quelle mémoire de travail (I<scratchpad>) il utilisait pour allouer et 
libérer les valeurs temporaires et lexicales. 

=item panic: pad_sv po

(panique : C<pad_sv po>) (P) Un décalage incorrect dans la mémoire de
travail (I<scratchpad>) a été détecté en interne. 

=item panic: pad_swipe curpad

(panique : C<pad_swipe curpad>) (P) Le compilateur ne sait plus
quelle mémoire de travail (I<scratchpad>) il utilisait pour allouer et 
libérer les valeurs temporaires et lexicales. 

=item panic: pad_swipe po

(panique : C<pad_swipe po>) (P) Un décalage incorrect dans la mémoire
de travail (I<scratchpad>) a été détecté en interne. 

=item panic: pp_iter

(panique : C<pp_iter>) (P) L'itérateur de C<foreach> a été appelé
dans un contexte qui n'était pas un contexte de boucle. 

#if defined(perldiag561)
=item panic: pp_match

(panique : C<pp_match>I<%s>) (P) La routine interne C<pp_match> a été appelée avec
des données opératoires invalides.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item panic: pp_match%s

(panique : C<pp_match>I<%s>) (P) La routine interne C<pp_match> a été appelée avec
des données opératoires invalides.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item panic: pp_split

(panique : C<pp_split>) (P) Quelque-chose de terrible a mal tourné en préparant
un C<split>.

#endif
=item panic: realloc

(panique : C<realloc>) (P) Quelque chose a demandé un nombre négatif
d'octets à C<realloc>. 

=item panic: restartop

(panique C<restartop>) (P) Une routine interne a demandé un C<goto>
(ou quelque chose de semblable) mais n'a pas fourni de destination. 

=item panic: return

(panique : C<return>) (P) Nous avons passé l'élément du dessus de la
pile de contexte à un sous-programme ou à un contexte d'C<eval> pour
découvrir alors que l'on n'était ni dans un sous-programme, ni dans
un contexte d'C<eval>. 

=item panic: scan_num

(panique : C<scan_num>) (P) La fonction interne de Perl C<scan_num> a
été appelée sur quelque chose qui n'était pas un nombre. 

=item panic: sv_insert

(panique : C<sv_insert>) (P) On a demandé à la routine C<sv_insert>
d'enlever plus de chaînes qu'il en existe. 

=item panic: top_env

(panique : C<top_env>) (P) Le compilateur a tenté de faire un C<goto>
ou quelque chose d'aussi bizarre. 

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item panic: utf16_to_utf8: odd bytelen

(panique : C<utf16_to_utf8>, C<bytlen> impair) (P) Quelque-chose a essayé
d'appeler C<utf16_to_utf8> avec une longueur impaire (longueur exprimée en octets).

#endif
=item panic: yylex

(panique : C<yylex>) (P) L'analyseur lexical s'est retrouvé dans un
mauvais état en traitant un modificateur de casse
(majuscule/minuscule). 

=item Parentheses missing around "%s" list

(Parenthèses manquantes autour de la liste « I<%s> ») (W parenthesis)
Vous avez écrit quelque chose comme :

  my $truc, $machin = @_;


alors que vous vouliez dire :

  my ($truc, $machin) = @_;


Souvenez-vous que C<my>, C<our> et C<local> regroupent plus fortement
que la virgule.

#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item (perhaps you forgot to load "%s"?)

(peut-être avez-vous oublié de charger « I<%s> » ?) (F) C'est une supposition
qui complète le message « Can't locate object method \"%s\" via package \"%s\" »
(« Impossible de trouver la méthode objet « I<%s> » via le paquetage
I<%s> »). Cela signifie souvent que la méthode a besoin d'un paquetage qui
n'a pas été chargé.

#endif
#if defined(perldiag560)
=item Perl %3.3f required--this is only version %s, stopped

(Perl I<%3.3f> requis --- il ne s'agit que de la version I<%s>,
arrêt) (F) Le module en question utilise des fonctionnalités offertes
par une version plus récente que celle exécutée actuellement. Depuis
combien de temps n'avez-vous pas fait de remise à niveau ? 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item perlio: argument list not closed for layer "%s"

(perlio : la liste d'arguments de la couche « I<%s> » n'est pas fermée) (S)
Lorsque vous empilez une couche avec arguments sur le système d'entrées-sorties
de Perl, vous avez oublié la parenthèse fermante qui clôt la liste 
d'arguments. (Les couches s'occupent de transformer les données entre leur
représentation externe et leur représentation interne.) Perl a arrêté
l'analyse des couches à ce point, et n'a pas essayé d'empiler cette
couche. Si votre programme n'utilise pas explicitement l'opération qui
a échoué, le message peut être provoqué par la valeur de la
variable d'environnement C<PERLIO>.

#endif
#if defined(perldiag580)
=item perlio: argument list not closed for layer "%s"

(W layer) When pushing a layer with arguments onto the Perl I/O system you
forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item perlio: invalid separator character %s in attribute list

(perlio : caractère séparateur I<%s> invalide dans la liste d'attributs)
(S) Lorsque vous empilez des couches sur le système d'entrées-sorties de Perl,
vous avez utilisé autre chose qu'un espace ou un deux-points entre les
éléments d'une couche. Si l'attribut précédent a une liste de paramètres
entre parenthèses, peut-être cette liste a-t-elle été terminée trop tôt.

#endif
#if defined(perldiag580)
=item perlio: invalid separator character %s in layer specification list %s

(W layer) When pushing layers onto the Perl I/O system, something other than a
colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item perlio: unknown layer "%s"

(perlio : couche « I<%s> » inconnue) (S) Le programme a essayé
d'empiler une couche inconnue sur le système d'entrées-sorties de
Perl. (Les couches s'occupent de transformer les données entre leur
représentation externe et leur représentation interne.)  Veuillez
noter que certaines couches, comme C<mmap>, ne sont pas supportées par
tous les environnements. Si votre programme n'utilise pas
explicitement l'opération qui a échoué, le message peut être provoqué
par la valeur de la variable d'environnement C<PERLIO>.

#endif
#if defined(perldiag580)
=item perlio: unknown layer "%s"

(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

#endif
#if defined(perldiag580) or defined(perldiag573) or defined(perldiag561)
=item Perl %s required--this is only version %s, stopped

(Perl I<%s> requis --- il ne s'agit que de la version I<%s>,
arrêt) (F) Le module en question utilise des fonctionnalités offertes
par une version plus récente que celle exécutée actuellement. Depuis
combien de temps n'avez-vous pas fait de remise à niveau ? 
Cf. L<perlfunc/require>.

#endif
#if defined(perldiag573) or defined(perldiag561) or defined(perldiag560)
=item PERL_SH_DIR too long

(C<PERL_SH_DIR> trop long) (F) Il s'agit d'une erreur spécifique à
OS/2. C<PERL_SH_DIR> est le répertoire où se trouve le shell I<sh>.
Voir C<PERL_SH_DIR> dans le fichier I<README.os2> compris dans la
distribution de Perl. 

#endif
#if defined(perldiag560)
=item perl: warning: Setting locale failed.

(perl : avertissement : Échec avec la configuration des locales) (S)
Le message d'avertissement complet ressemblera quelque peu à :

  perl: warning: Setting locale failed.
      perl: warning: Please check that your locale settings:
              LC_ALL = "Fr_FR",
              LANG = (unset)
          are supported and installed on your system.
      perl: warning: Falling back to the standard locale ("C").
  I<N.d.T.> :
    perl : avertissement : Échec avec la configuration des locales.
        perl : avertissement : Merci de vérifier que votre configuration des locales :
                LC_ALL = "Fr_FR",
                LANG = (non configuré)
            soit supportée et installée sur votre système.
        perl : avertissement : Retour aux locales standards ("C").


(La configuration des locales qui a échoué variera.) Cette erreur
indique que Perl a détecté que vous ou votre administrateur système
avez configuré les variables du système ainsi nommées mais Perl n'a
pas pu utiliser cette configuration. Ce n'est pas mortel,
heureusement : il existe une locale par défaut appelée « C » que Perl
peut et va utiliser pour le script puisse ainsi fonctionner. Mais
avant que vous résolviez vraiment ce problème, vous allez toutefois
avoir le même message d'erreur à chaque fois que vous lancerez Perl.
La manière de vraiment résoudre le problème peut être trouvée dans
I<perllocale>(1), à la section « Locale Problems ».

#endif
#if defined(perldiag573) or defined(perldiag561)
=item perl: warning: Setting locale failed.

(perl : avertissement : Échec avec la configuration des locales) (S)
Le message d'avertissement complet ressemblera quelque peu à :

  perl: warning: Setting locale failed.
      perl: warning: Please check that your locale settings:
              LC_ALL = "Fr_FR",
              LANG = (unset)
          are supported and installed on your system.
      perl: warning: Falling back to the standard locale ("C").
  I<N.d.T.> :
    perl : avertissement : Échec avec la configuration des locales.
        perl : avertissement : Merci de vérifier que votre configuration des locales :
                LC_ALL = "Fr_FR",
                LANG = (non configuré)
            soit supportée et installée sur votre système.
        perl : avertissement : Retour aux locales standards ("C").


(La configuration des locales qui a échoué variera. Dans l'exemple ci-dessus,
C<LC_ALL> vaut C<"Fr_FR"> et C<LANG> n'a pas de valeur.) Cette erreur
indique que Perl a détecté que vous ou votre fournisseur ou votre administrateur système
avez configuré les variables du système ainsi nommées mais Perl n'a
pas pu utiliser cette configuration. Ce n'est pas mortel,
heureusement : il existe une locale par défaut appelée « C » que Perl
peut et va utiliser pour le script puisse ainsi fonctionner. Mais
avant que vous résolviez vraiment ce problème, vous allez toutefois
avoir le même message d'erreur à chaque fois que vous lancerez Perl.
La manière de vraiment résoudre le problème peut être trouvée dans
I<perllocale>(1), à la section « Locale Problems ».

#endif
#if defined(perldiag573)
=item Permission denied

(Permission refusée) (F) L'émulateur setuid de I<suidperl> a décidé
que vous n'étiez pas quelqu'un de gentil.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Permission denied

(Permission refusée) (F) L'émulateur setuid de I<suidperl> a décidé
que vous n'étiez pas quelqu'un de bon. 

#endif
=item pid %x not a child

(le pid I<%x> n'est pas un fils) (W exec) Il s'agit d'une alerte
spécifique à VMS ; on a demandé à C<waitpid> d'attendre un processus
qui n'est pas un sous-processus du processus courant. Même si cela
est correct dans la perspective de VMS, cela n'est probablement pas
ce que vous vouliez. 

#if defined(perldiag580) or defined(perldiag573)
=item P must have an explicit size

(« P » doit avoir une taille explicite) (F) Le format P pour
C<unpack> doit avoir une taille explicite, pas C<*>.

#endif
#if defined(perldiag561)
=item POSIX class [:%s:] unknown

(Classe de caractères POSIX C<[:>I<%s>C<:]> inconnue) (F) La classe
dans la syntaxe pour une classe de caractères C<[: :]> est inconnue.
Cf. L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item POSIX class [:%s:] unknown in regex;

marked by <-- HERE in m/%s/

(Classe de caractères POSIX C<[:>I<%s>C<:]> inconnue) (F) La classe dans la
syntaxe pour une classe de caractères C<[: :]> est inconnue. 
La mention « <-- HERE » indique l'endroit où le problème a été constaté.
Notez bien que les classes POSIX n'ont B<pas> de préfixe C<is> comme
les classes C correspondantes. En d'autres termes, il faut écrire
C<[[:print:]]> au lieu de C<isprint>. Cf. L<perlre>.

#endif
=item POSIX getpgrp can't take an argument

(C<getpgrp> POSIX ne prend pas d'argument) (F) Votre système dispose
de la fonction POSIX C<getpgrp>, qui ne prend pas d'argument, au
contraire de la version BSD, qui prend un PID. 

#if defined(perldiag561)
=item POSIX syntax [%s] belongs inside character classes

(La syntaxe POSIX C<[>I<%s>]> doit se trouver à l'intérieur d'une
classe dans une expression régulière) (W unsafe) Les constructions de
classe C<[: :]>, C<[= =]> et C<[. .]> doivent obligatoirement se
trouver I<à l'intérieur> d'une classe de caractères, et les C<[]> font
partie de la construction. Exemple C</[012[:alpha:]345]/>. Notez que
C<[= =]> et C<[. .]> ne sont pas encore implémentés ; ce sont
simplement des syntaxes réservées pour les extensions à venir et
causent des erreurs fatales. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item POSIX syntax [%s] belongs inside character classes in regex;

marked by <-- HERE in m/%s/

(La syntaxe POSIX C<[>I<%s>]> doit se trouver à l'intérieur d'une
classe dans une expression régulière) (W regexp) Les constructions de
classe C<[: :]>, C<[= =]> et C<[. .]> doivent obligatoirement se
trouver I<à l'intérieur> d'une classe de caractères, et les C<[]> font
partie de la construction. Exemple C</[012[:alpha:]345]/>. Notez que
C<[= =]> et C<[. .]> ne sont pas encore implémentés ; ce sont
simplement des syntaxes réservées pour les extensions à venir et
causent des erreurs fatales. La mention « <-- HERE » indique
l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag561)
=item POSIX  syntax [. .] is reserved for future extensions

(Syntaxe C<[. .]> pour une classe de caractères réservée pour de
futures extensions) (F regexp) À l'intérieur des classes de caractères
dans les expressions régulières (C<[]>), la syntaxe commençant par
C<[.> et se terminant par C<.]> est réservée pour de futures
extensions. Si vous avez besoin de représenter de telles séquences de
caractères à l'intérieur d'une classe de caractères dans une
expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[.> et C<.\]>.

#endif
#if defined(perldiag561)
=item POSIX syntax [= =] is reserved for future extensions

(Syntaxe C<[= =]> pour une classe de caractères réservée pour de
futures extensions) (F) A l'intérieur des classes de caractères
dans les expressions régulières (C<[]>), la syntaxe commençant par
C<[=> et se terminant par C<=]> est réservée pour de futures
extensions. Si vous avez besoin de représenter de telles séquences de
caractères à l'intérieur d'une classe de caractères dans une
expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[=> et C<=\]>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item POSIX syntax [. .] is reserved for future extensions in regex;

marked by <-- HERE in m/%s/

(Syntaxe C<[. .]> pour une classe de caractères réservée pour de
futures extensions) (W regexp) À l'intérieur des classes de caractères
dans les expressions régulières (C<[]>), la syntaxe commençant par
C<[.> et se terminant par C<.]> est réservée pour de futures
extensions. Si vous avez besoin de représenter de telles séquences de
caractères à l'intérieur d'une classe de caractères dans une
expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[.> et C<.\]>. La mention « <-- HERE » indique
l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item POSIX syntax [= =] is reserved for future extensions in regex;

marked by <-- HERE in m/%s/

(Syntaxe C<[= =]> pour une classe de caractères réservée pour de
futures extensions) (W regexp) A l'intérieur des classes de caractères
dans les expressions régulières (C<[]>), la syntaxe commençant par
C<[=> et se terminant par C<=]> est réservée pour de futures
extensions. Si vous avez besoin de représenter de telles séquences de
caractères à l'intérieur d'une classe de caractères dans une
expression régulière, protégez simplement les crochets avec un
anti-slash : C<\[=> et C<=\]>. La mention « <-- HERE » indique
l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
=item Possible attempt to put comments in qw() list

(Peut-être une tentative de mettre des commentaires dans une liste
C<qw()>) (W qw) Les listes C<qw> contiennent des éléments séparés par
des espacements ; comme avec les chaînes littérales, les caractères
de commentaires ne sont pas ignorés, mais au lieu de ça traités comme
des données littérales. (Vous auriez pu utiliser des délimiteurs
différents des parenthèses indiquées ici ; les accolades sont
également fréquemment utilisées.)

Vous avez probablement écrit quelque chose comme ceci :

  @liste = qw(
      a # un commentaire 
      b # un autre commentaire
  );


alors que vous auriez dû écrire cela :

  @liste = qw(
      a
      b
  );


Si vous voulez vraiment des commentaires, construisez votre liste à
l'ancienne, avec des apostrophes et des virgules :

  @liste = (
      'a', # un commentaire
      'b', # un autre commentaire
  );

=item Possible attempt to separate words with commas

(Peut-être une tentative de séparer les mots avec des virgules) (W qw) Les
listes C<qw> contiennent des éléments séparés par des espacements ;
les virgules ne sont donc pas nécessaires pour séparer les éléments.
(Vous auriez pu utiliser des délimiteurs différents des parenthèses
indiquées ici ; les accolades sont également fréquemment utilisées.)

Vous avez probablement écrit quelque chose comme ceci :

  qw( a, b, c );

ce qui place les caractères virgules parmi certains éléments de la
liste. Écrivez-le sans virgules si vous ne voulez pas les voir
apparaître dans vos données :

  qw( a b c );

=item Possible memory corruption: %s overflowed 3rd argument

(Corruption possible de la mémoire : le 3ème argument de I<%s> a
débordé) (F) Un C<ioctl> ou un C<fcntl> a renvoyé plus que ce Perl
demandait. Perl anticipe un tampon de taille raisonnable mais place
un octet de sentinelle à la fin du tampon au cas où. On a écrasé cet
octet de sentinelle et Perl suppose que la mémoire est maintenant
corrompue. Cf. L<perlfunc/ioctl>.

#if defined(perldiag580) or defined(perldiag573)
=item Possible unintended interpolation of %s in string

(Interpolation de I<%s> dans une chaîne peut-être non désirée) (W ambiguous)
Vous avez écrit « C<@machin> » dans une chaîne entre guillemets doubles,
mais il n'existe aucun tableau  C<@machin> visible à cet endroit du programme.
Si vous voulez une chaîne littérale  C<@machin>, il faut écrire  C<\@machin> ;
sinon, essayez de trouver ce qu'il est advenu du tableau que vous avez
égaré apparamment.

#endif
=item Possible Y2K bug: %s

(Possible bogue de l'an 2000) (W y2k) Vous être en train de
concaténer le nombre 19 avec un autre nombre, ce qui pourrait être un
problème potentiel pour l'an 2000. 

=item pragma "attrs" is deprecated, use "sub NAME : ATTRS" instead

(le pragma « C<attrs> » est déprécié, utilisez à la place « C<sub NOM
: ATTRS> ») (W deprecated) Vous avez écrit quelque chose comme ceci :

  sub fait
  {
      use attrs qw(locked)
  }


Vous auriez dû utiliser à la place la nouvelle syntaxe de déclaration :

  sub fait : locked
  {
      ...

Le pragma C<use attrs> est maintenant obsolète et n'est fourni que
pour assurer une compatibilité antérieure. Cf. L<perlsub/"Subroutine
Attributes">.

=item Precedence problem: open %s should be open(%s)

(Problème de précédence : C<open> I<%s> devrait être
C<open(>I<%s>C<)>) (S precedence) L'ancienne construction irrégulière :

  open TRUC || die;

est maintenant mal interprétée en :

  open(TRUC || die);

à cause la stricte régularisation de la grammaire de Perl 5 en
opérateurs unaires et opérateur de listes. (L'ancien C<open> était un
peu des deux.) Vous devez mettre des parenthèses autour du handle de
fichier ou utiliser le nouvel opérateur C<or> à la place de C<||>.

=item Premature end of script headers

(Fin prématurée des en-têtes du script) Voir C<Server error>. 

=item printf() on closed filehandle %s

(C<printf()> sur le handle de fichier fermé I<%s>) (W closed) Le
handle de fichier dans lequel vous écrivez s'est retrouvé fermé à un
moment auparavant. Vérifier le flux logique de votre programme. 

=item print() on closed filehandle %s

(C<print()> sur le handle de fichier fermé I<%s>) (W closed) Le
handle de fichier dans lequel vous imprimez s'est retrouvé fermé à un
moment auparavant. Vérifier le flux logique de votre programme. 

#if defined(perldiag560)
=item Process terminated by SIG%s

(Processus terminé par C<SIG>I<%s>) (W) Il s'agit d'un message
standard formulé par les applications OS/2, alors que les
applications Unix meurent en silence. C'est considéré comme une
caractéristique du portage sous OS/2. Cet avertissement peut
facilement être désactivé en positionnant les gestionnaires de
signaux appropriés. Voir également « Process terminated by
C<SIGTERM>/C<SIGINT> » (I<N.d.T.> : Processus terminé par
C<SIGTERM>/C<SIGINT>) dans le fichier I<README.os2> livré avec la
distribution de Perl. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Process terminated by SIG%s

(Processus terminé par C<SIG>I<%s>) (W) Il s'agit d'un message
standard formulé par les applications OS/2, alors que les
applications Unix meurent en silence. C'est considéré comme une
caractéristique du portage sous OS/2. Cet avertissement peut
facilement être désactivé en positionnant les gestionnaires de
signaux appropriés, voir L<perlipc/"Signals">. Voir également « Process terminated by
C<SIGTERM>/C<SIGINT> » (I<N.d.T.> : Processus terminé par
C<SIGTERM>/C<SIGINT>) dans le fichier I<README.os2> livré avec la
distribution de Perl. 

#endif
=item Prototype mismatch: %s vs %s

(Non correspondance de prototypes : I<%s> contre I<%s>) (S) La
sous-fonction qui est en train d'être déclarée ou définie a été
précédemment déclarée ou définie avec un prototype différent. 

#if defined(perldiag580)
=item Prototype not terminated

(F) You've omitted the closing parenthesis in a function prototype
definition.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Prototype not terminated

(Prototype non terminé) (F) Vous avez oublié la parenthèse fermante
dans la définition du prototype d'une fonction.

#endif
#if defined(perldiag573)
=item Quantifier follows nothing in regex;

marked by <-- HERE in m/%s/

(Le quantifiant ne suit rien dans l'expression régulière) (F) Vous avez
commencé une expression rationnelle avec un quantifiant. Mettez un
anti-slash devant si vous vouliez l'employer au sens littéral. 
La mention « <-- HERE » indique l'endroit où le problème a été constaté.
Cf. L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Quantifier in {,} bigger than %d in regex;

marked by <-- HERE in m/%s/

(Quantifiant entre C<{,}> plus grand que I<%d> dans une regexp) (F) Il
existe actuellement une limite aux valeurs C<min> et C<max> dans une
construction C<{min,max}>. La mention « <-- HERE » indique l'endroit
où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Quantifier unexpected on zero-length expression;

marked by <-- HERE in m/%s/

(Quantifiant inopiné sur une expression de longueur zéro) (W regexp)
Vous avez appliqué un quantifiant à un endroit où cela n'a pas de sens,
comme une assertion de longueur nulle. Essayez de mettre ce quantifiant
à l'intérieur de l'assertion. Par exemple, pour vérifier la correspondance
avec un « C<abc> » suivi de trois répétitions de « C<xyz> », il faut coder
C</abc(?=(?:xyz){3})/>, non pas C</abc(?=xyz){3}/>.

La mention « <-- HERE » indique l'endroit
où le problème a été constaté.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Range iterator outside integer range

(Itérateur d'intervalle en dehors d'un intervalle) (F) L'un des
arguments numériques (ou les deux) de l'opérateur d'intervalle C<..>
est en dehors de l'intervalle qui peut être représenté en interne par
des entiers. Une façon de contourner cela consiste à forcer Perl à
utiliser des incréments de chaînes magiques en ajoutant C<0> au début
de vos nombres.

#endif
#if defined(perldiag561) or defined(perldiag560)
=item Range iterator outside integer range

(Itérateur d'intervalle en dehors d'un intervalle) (F) L'un (ou les
deux) des arguments numériques de l'opérateur d'intervalle C<..> est
en dehors de l'intervalle qui peut être représenté en interne par des
entiers. Une façon de contourner cela consiste à forcer Perl à utiliser des
incréments de chaînes magiques en ajoutant C<0> au début de vos
nombres. 

#endif
=item readline() on closed filehandle %s

(C<readline()> sur un handle de fichier fermé I<%s>) (W closed) Le
handle de fichier dans lequel vous êtes en train de lire s'est
retrouvé fermé un moment auparavant. Vérifier le flux logique de
votre programme. 

=item Reallocation too large: %lx

(Réallocation trop grande : I<%lx>) (F) Vous ne pouvez allouer plus
de 64K sur une machine MS-DOS. 

=item realloc() of freed memory ignored

(C<realloc()> sur de la mémoire libérée, ignoré) (S malloc) Une
routine interne a appelé C<realloc> sur quelque chose qui avait déjà
été libéré. 

#if defined(perldiag580) or defined(perldiag573)
=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch

(Recompilez perl avec C<-DDEBUGGING> pour utiliser l'option B<-D>) (F
debugging) Vous ne pouvez utiliser l'option B<-D> que si Perl a été
compilé avec le code qui produit la sortie désirée ; comme cela
implique une certaine surcharge, cela n'a pas été inclus dans votre
installation de Perl. 

#endif
#if defined(perldiag560)
=item Recompile perl with -DDEBUGGING to use -D switch

(Recompilez perl avec C<-DDEBUGGING> pour utiliser l'option B<-D>) (F
debugging) Vous ne pouvez utiliser l'option B<-D> que si Perl a été
compilé avec le code qui produit la sortie désirée ; comme cela
implique une certaine surcharge, cela n'a pas été inclus dans votre
installation de Perl. 

#endif
=item Recursive inheritance detected in package '%s'

(Héritage récursif détecté dans le paquetage 'I<%s>') (F) Plus de 100
niveaux d'héritage ont été utilisés. Ceci indique probablement une
boucle accidentelle dans votre hiérarchie de classes. 

#if defined(perldiag580) or defined(perldiag573)
=item Recursive inheritance detected while looking for method %s

(Héritage récursif détecté en recherchant la méthode 'I<%s>') (F) Plus
de 100 niveaux d'héritages ont été utilisés. Ceci indique probablement
une boucle accidentelle dans votre hiérarchie de classes.

#endif
#if defined(perldiag560)
=item Recursive inheritance detected while looking for method '%s' in package '%s'

(Héritage récursif détecté en recherchant la méthode 'I<%s>' dans le
paquetage 'I<%s>') (F) Plus de 100 niveaux d'héritages ont été
utilisés. Ceci indique probablement une boucle accidentelle dans
votre hiérarchie de classes. 

#endif
=item Reference found where even-sized list expected

(Référence trouvée où une liste de taille paire était attendue) (W
misc) Vous avez donné une seule référence là où Perl s'attendait à
avoir une liste avec un nombre pair d'éléments (pour affection à un
hachage). Cela veut habituellement dire que vous avez utilisé le
constructeur de hachage anonyme alors que vous vouliez utiliser des
parenthèses. Dans tous les cas, un hachage exige des B<paires>
clef/valeur.

  %hachage = { un => 1, deux => 2, };      # MAUVAIS
  %hachage = [ qw( un tableau anonyme /)]; # MAUVAIS
  %hachage = ( un => 1, deux => 2, );      # juste
  %hachage = qw( un 1 deux 2 );            # également correct

=item Reference is already weak

(La référence est déjà lâche) (W misc) Vous avez tenté de relâcher
une référence qui était déjà lâche. Ceci n'a aucun effet. 

=item Reference miscount in sv_replace()

(Mauvais compte de références dans C<sv_replace()>) (W internal) On a
passé à la fonction interne C<sv_replace> un nouvel SV avec un nombre
de références différent de 1. 

#if defined(perldiag580) or defined(perldiag573)
=item Reference to nonexistent group in regex;

marked by <-- HERE in m/%s/

(Référence à un groupe inexistant dans une expression régulière) (F)
Vous avez écrit quelque chose du style C<\7> dans votre expression régulière,
mais il y a moins de sept parenthèses capturant des sous-expressions.
Si vous voulez insérer le caractère de code 7 dans l'expression régulière,
préfixez-le d'un zéro, pour obtenir un nombre à deux chiffres ou plus : C<\07>.

La mention « <-- HERE » indique l'endroit dans l'expression régulière où le
problème a été constaté.

#endif
=item regexp memory corruption

(Corruption de la mémoire de l'expression régulière) (P) Le moteur
d'expressions régulières s'est trompé avec ce que l'expression
régulière lui a donné. 

#if defined(perldiag560)
=item regexp *+ operand could be empty

(L'opérande C<*+> de l'expression régulière pourrait être vide) (F)
La partie d'une expression régulière sujette au quantifiant C<*> ou
C<+> pourrait correspondre à une chaîne vide. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Regexp out of space

(Plus d'espace pour l'expression régulière) (P) Il s'agit d'une
erreur « qui ne peut pas arriver » car C<safemalloc> aurait dû la
capturer plus tôt. 

#endif
#if defined(perldiag560)
=item regexp out of space

(plus d'espace pour l'expression régulière) (P) Il s'agit d'une
erreur « qui ne peut pas arriver » car C<safemalloc> aurait dû la
capturer plus tôt. 

#endif
=item Repeat count in pack overflows

(Dépassement du compteur de répétitions dans C<pack>) (F) Vous ne
pouvez pas spécifier un compteur de répétitions tellement grand qu'il
dépasse la limite pour vos entiers signés. Cf. L<perlfunc/pack>.

=item Repeat count in unpack overflows

(Dépassement du compteur de répétitions dans C<unpack>) (F) Vous ne
pouvez pas spécifier un compteur de répétitions tellement grand qu'il
dépasse la limite pour vos entiers signés. Cf. L<perlfunc/unpack>.

=item Reversed %s= operator

(Opérateur I<%s>C<=> inversé) (W syntax) Vous avez écrit votre
opérateur d'affectation à l'envers. Le C<=> doit toujours arriver en
dernier, pour éviter l'ambiguïté avec les opérateurs unaires
suivants. 

=item Runaway format

(Format s'échappant) (F) Votre format contenait la séquence de
répétition jusqu'à un caractère blanc C<~~> mais il a produit 200
lignes d'un coup et la 200ème ligne ressemblait exactement à la
199ème. Apparemment vous ne vous êtes pas arrangé pour que les
arguments soit consommés, soit en utilisant C<^> au lieu de C<@> (pour
les variables scalaires), soit en faisant un C<shift> ou un C<pop>
(pour les variables de tableaux). Cf. L<perlform>.

#if defined(perldiag580) or defined(perldiag573)
=item Scalars leaked: %d

(Fuite de scalaires : I<%d>) (P) Quelque chose s'est mal passé dans
la gestion interne des scalaires de Perl : les variables scalaires
n'ont pas été toutes désallouées au moment où l'interprêteur Perl
s'est terminé. Habituellement, c'est le signe d'une fuite de mémoire,
ce qui est mauvais, surtout si le programme est destiné à tourner
pendant une longue durée.

#endif
=item Scalar value @%s[%s] better written as $%s[%s]

(Valeur scalaire C<@>I<%s>C<[>I<%s>C<]> mieux écrite avec
C<$>I<%s>C<[>I<%s>C<]>) (W syntax) Vous avez utilisé une tranche de
tableau (indiqué par C<@>) pour sélectionner un seul élément d'un
tableau. Généralement il vaut mieux demander une valeur scalaire
(indiquée par C<$>). La différence est que C<$truc[&machin]> se
comporte toujours comme un scalaire, à la fois lors de son
affectation et lors de l'évaluation de son argument, alors que
C<@truc[&machin]> se comporte comme une liste lorsque vous y affectez
quelque chose en fournissant un contexte de liste à son indice, ce
qui peut donner des choses étranges si vous vous attendez à un seul
indice. Cf. L<perlref>.

D'un autre côté, si vous espériez vraiment traiter l'élément du
tableau comme une liste, vous devez regarder comment fonctionnent les
références car Perl ne va pas par magie faire la conversion entre les
scalaires et les listes à votre place. Cf. L<perlref>.

=item Scalar value @%s{%s} better written as $%s{%s}

(Valeur scalaire C<@>I<%s>C<{>I<%s>C<}> mieux écrite avec
C<$>I<%s>C<{>I<%s>C<}>) (W syntax) Vous avez utilisé une tranche de
hachage (indiquée par C<@>) pour sélectionner un seul élément d'un
hachage. Généralement il vaut mieux demander une valeur scalaire
(indiquée par C<$>). La différence est que C<$truc{&machin}> se
comporte toujours comme un scalaire, à la fois lors de son
affectation et lors de l'évaluation de son argument, alors que
C<@truc{&machin}> se comporte comme une liste lorsque vous y affectez
quelque chose en fournissant un contexte de liste à son indice, ce
qui peut donner des choses étranges si vous vous attendez à un seul
indice.

D'un autre côté, si vous espériez vraiment traiter l'élément du
hachage comme une liste, vous devez regarder comment fonctionnent les
références car Perl ne va pas par magie faire la conversion entre les
scalaires et les listes à votre place. Cf. L<perlref>.

=item Script is not setuid/setgid in suidperl

(Le script n'est pas en setuid/setgid dans suidperl) (F)
Curieusement, le programme I<suidperl> a été invoqué sur un script
qui n'a pas de bit setuid ou setgid bit positionné. Cela n'a vraiment
aucun sens. 

=item Search pattern not terminated

(Motif de recherche non terminé) (F) L'analyseur lexical n'a pas pu
trouver le délimiteur final d'une construction C<//> ou C<m{}>.
Souvenez-vous que les délimiteurs fonctionnant par paires 
« ouvrant/fermant » (tels que les parenthèses, les crochets, les
accolades ou les signes inférieur/supérieur) comptent les niveaux
imbriqués. Omettre le C<$> au début d'une variable C<$m> peut causer
cette erreur. 

#if defined(perldiag560)
=item %sseek() on unopened file

(I<%s>C<seek()> sur un fichier non ouvert) (W unopened) Vous avez
essayé d'utiliser la fonction C<seek> ou C<sysseek> sur un handle de
fichier qui soit n'a jamais été ouvert, soit a été fermé depuis. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item %sseek() on unopened filehandle

(I<%s>C<seek()> sur un handle de fichier non ouvert) (W unopened) Vous avez
essayé d'utiliser la fonction C<seek> ou C<sysseek> sur un handle de
fichier qui soit n'a jamais été ouvert, soit a été fermé depuis. 

#endif
=item select not implemented

(C<select> non implémenté) (F) Cette machine n'implémente pas l'appel
système C<select>. 

#if defined(perldiag580) or defined(perldiag573)
=item Self-ties of arrays and hashes are not supported

(Les auto-liens de tableaux et de hachages ne sont pas supportés) (F)
Les auto-liens, ou liens récursifs, pour les tableaux et pour les
hachages ne sont pas supportés dans la version actuelle.

#endif
=item Semicolon seems to be missing

(Il semble manquer un point-virgule) (W semicolon) Une quasi-erreur
de syntaxe a probablement été causée par un point-virgule manquant ou
un autre opérateur manquant peut-être, comme une virgule. 

=item semi-panic: attempt to dup freed string

(demi-panique : tentative de dupliquer une chaîne libérée) (S
internal) La routine interne C<newSVsv> a été appelée pour dupliquer
un scalaire qui avait été marqué auparavant comme étant libre. 

=item sem%s not implemented

(C<sem>I<%s> non implémenté) (F) Vous n'avez pas d'implémentation des
sémaphores des IPC System V sur votre système. 

=item send() on closed socket %s

(C<send()> sur une socket fermée) (W closed) La socket dans laquelle
vous envoyer des données s'est retrouvée fermée à un moment
auparavant. Vérifiez le flux logique de votre programme. 

#if defined(perldiag560)
=item Sequence (? incomplete

(Séquence C<(?> incomplète) (F) Une expression régulière finissait
par une extension incomplète C<(?>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Sequence (? incomplete in regex; marked by <-- HERE in m/%s/

(Séquence C<(?> incomplète) (F) Une expression régulière finissait par
une extension incomplète C<(?>. La mention « <-- HERE » indique
l'endroit dans l'expression régulière où le problème a été constaté.
Cf L<perlre>.

#endif
#if defined(perldiag560)
=item Sequence (?%s...) not implemented

(Séquence C<(?>I<%s>C<...)> non implémentée) (F) Une proposition
d'extension des expressions régulières a réservé le caractère mais
n'a pas encore été écrite. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Sequence (?%s...) not implemented in regex;

marked by <-- HERE in m/%s/

(Séquence C<(?>I<%s>C<...)> non implémentée dans l'expression
régulière) (F) Une proposition d'extension des expressions régulières
a réservé le caractère mais n'a pas encore été écrite. La mention 
« <-- HERE » indique l'endroit où le problème a été constaté. Cf
L<perlre>.

#endif
#if defined(perldiag560)
=item Sequence (?%s...) not recognized

(Séquence C<(?>I<%s>C<...)> non reconnue) (F) Vous avez utilisé une
expression régulière qui n'a aucun sens. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Sequence (?%s...) not recognized in regex;

marked by <-- HERE in m/%s/

(Séquence C<(?>I<%s>C<...)> non reconnue) (F) Vous avez utilisé une
expression régulière qui n'a aucun sens. La mention « <-- HERE »
indique l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag560)
=item Sequence (?#... not terminated

(Séquence C<(?#XS...> non terminée) (F) Un commentaire d'une expression
régulière doit se terminer par une parenthèse fermée. Les parenthèses
imbriquées ne sont pas autorisées. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Sequence (?#... not terminated in regex;

marked by <-- HERE in m/%s/

(La séquence C<(#>I<%s>C<...)> n'est pas terminée) (F) Un commentaire
inclus dans une expression rationnelle doit se terminer par une
parenthèse. L'imbrication de parenthèses dans un commentaire est
interdite. La mention « <-- HERE » indique l'endroit dans
l'expression régulière où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Sequence (?{...}) not terminated or not {}-balanced in regex;

marked by <-- HERE in m/%s/

(La séquence C<(?{...})> n'est pas terminée, ou les accolades sont
déséquilibrées dans l'expression rationnelle) (F) Si le contenu d'une
clause C<(?{...})> comporte des accolades, il faut qu'elles soient
équilibrées pour que Perl puisse détecter correctement la fin de la
clause. La mention « <-- HERE » indique l'endroit dans l'expression
régulière où le problème a été constaté. Cf L<perlre>.

#endif
=item 500 Server error

(Erreur de serveur 500) Voir Server error (Erreur de serveur). 

#if defined(perldiag580) or defined(perldiag573)
=item Server error

(Erreur du serveur) Il s'agit du message d'erreur généralement vu
dans une fenêtre de navigateur lorsque vous essayez de lancer un
programme CGI (y compris SSI) sur le Web. Le véritable texte d'erreur
varie largement d'un serveur à l'autre. Les variantes les plus
fréquemment vues sont « C<500 Server error> », 
« C<Method (>I<quelque chose>C<) not permitted> », « C<Document contains no data> »,
« C<Premature end of script headers> » et « C<Did not produce a valid
header> » (« C<Erreur de serveur 500> », « C<Méthode
(>I<quelque_chose>C<) non permise> », « C<Le document ne contient
aucune donnée> », « C<Fin prématurée des en-têtes de script> » et 
« C<N'a pas produit d'en-tête valide> »). 

I<Il s'agit d'une erreur CGI, non d'une erreur Perl>.

Vous devez vous assurer que votre script soit exécutable, accessible
par l'utilisateur sous lequel le script CGI tourne (qui n'est
probablement pas le compte utilisateur sous lequel vous avez fait vos
tests), qu'il ne repose sur aucune variable d'environnement (telle
que C<PATH>) que l'utilisateur ne va pas avoir et qu'il ne se trouve
pas à un emplacement inatteignables pour le serveur CGI. Pour plus
d'informations, merci de voir les liens suivants :

    http://www.perl.com/CPAN/doc/FAQs/cgi/idiots-guide.html
    http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html
    ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
    http://hoohoo.ncsa.uiuc.edu/cgi/interface.html
    http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html

Vous pouvez également jeter un coup d'oeil à  L<perlfaq9>.

#endif
#if defined(perldiag560)
=item Server error

(Erreur du serveur) Il s'agit du message d'erreur généralement vu
dans une fenêtre de navigateur lorsque vous essayez de lancer un
programme CGI (y compris SSI) sur le Web. Le véritable texte d'erreur
varie largement d'un serveur à l'autre. Les variantes les plus
fréquemment vues sont « C<500 Server error> », « C<Method
(>I<something>C<) not permitted> », « C<Document contains no data> »,
« C<Premature end of script headers> » et « C<Did not produce a valid
header> » (« C<Erreur de serveur 500> », « C<Méthode
(>I<quelque_chose>C<) non permise> », « C<Le document ne contient
aucune donnée> », « C<Fin prématurée des en-têtes de script> » et 
« C<N'a pas produit d'en-tête valide> »). 

I<Il s'agit d'une erreur CGI, non d'une erreur Perl>.

Vous devez vous assurer que votre script soit exécutable, accessible
par l'utilisateur sous lequel le script CGI tourne (qui n'est
probablement pas le compte utilisateur sous lequel vous avez fait vos
tests), qu'il ne repose sur aucune variable d'environnement (telle
que C<PATH>) que l'utilisateur ne va pas avoir et qu'il ne se trouve
pas à un emplacement inatteignables pour le serveur CGI. Pour plus
d'informations, merci de voir les liens suivants :

    http://www.perl.com/CPAN/doc/FAQs/cgi/idiots-guide.html
    http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html
    ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
    http://hoohoo.ncsa.uiuc.edu/cgi/interface.html
    http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html

Vous devriez également regarder la FAQ Perl.

#endif
=item setegid() not implemented

(C<setegid()> non implémenté) (F) Vous avez essayé d'affecter C<$)>
mais votre système d'exploitation ne supporte pas l'appel système
C<setegid> (ou un équivalent) ou du moins c'est ce que pense
I<Configure>. 

=item seteuid() not implemented

(C<seteuid()> non implémenté) (F) Vous avez essayé d'affecter C<< $> >> 
mais votre système d'exploitation ne supporte pas l'appel système
C<seteuid> (ou un équivalent) ou du moins c'est ce que pense
I<Configure>. 

=item setpgrp can't take arguments

(C<setpgrp> ne peut pas prendre d'arguments) (F) Votre système
dispose de la fonction C<setpgrp> de BSD 4.2, qui ne prend pas
d'argument, au contraire de C<setpgid> POSIX, qui prend un ID de
processus et un ID de groupe de processus. 

=item setrgid() not implemented

(C<setrgid()> non implémenté) (F) Vous avez essayé d'affecter C<$(>
mais votre système d'exploitation ne supporte pas l'appel système
C<setrgid> (ou un équivalent) ou du moins c'est ce que pense
I<Configure>. 

=item setruid() not implemented

(C<setruid()> non implémenté) (F) Vous avez essayé d'affecter C<< $<
>> mais votre système d'exploitation ne supporte pas l'appel système
C<setruid> (ou un équivalent) ou du moins c'est ce que pense
I<Configure>. 

=item setsockopt() on closed socket %s

(C<setsockopt()> sur une socket fermée I<%s>) (W closed) Vous avez
essayé de positionner des options sur une socket fermée. Peut-être
avez-vous oublié de vérifier la valeur renvoyée par votre appel à
C<socket> ?  Cf. L<perlfunc/setsockopt>.

=item Setuid/gid script is writable by world

(Script C<setuid/setgid> modifiable par le monde entier) (F)
L'émulateur setuid ne lancera pas un script modifiable par le monde
entier car le monde entier peut très bien déjà l'avoir modifié. 

=item shm%s not implemented

(C<shm>I<%s> non implémenté) (F) Vous n'avez pas d'implémentation de
la mémoire partagée des IPC System V sur votre système. 

=item <> should be quotes

(C<< <> >> devraient être des apostrophes) (F) Vous avez écrit 
C<< require <fichier> >> alors que vous auriez dû écrire 
C<require 'fichier'>.

=item /%s/ should probably be written as "%s"

(C</>I<%s>C</> devrait probablement être écrit « C<%s> ») (W syntax)
Vous avez employé un motif là où Perl s'attendait à trouver une
chaîne, comme dans le premier argument de C<join>. Perl utilisera
comme chaîne le résultat vrai ou faux de la correspondance entre le
motif et C<$_>, ce qui n'est probablement pas ce que vous aviez en
tête. 

=item shutdown() on closed socket %s

(C<shutdown()> sur une socket fermée I<%s>) (W closed) Vous avez
essayé de faire un C<shutdown> sur une socket fermée. Cela semble quelque
peu superflu. 

=item SIG%s handler "%s" not defined

(Gestionnaire « I<%s> » pour C<SIG>I<%s> non défini) (W signal) Le
gestionnaire pour le signal nommé dans C<%SIG> n'existe en fait pas.
Peut-être l'avez-vous mis dans le mauvais paquetage ? 

=item sort is now a reserved word

(C<sort> est maintenant un mot réservé) (F) Il s'agit d'un ancien
message d'erreur que pratiquement personne ne rencontrera plus. Mais
avant que C<sort> soit un mot-clef, les gens l'utilisaient parfois
comme un handle de fichier. 

=item Sort subroutine didn't return a numeric value

(Le sous-programme de C<sort> n'a pas renvoyé de valeur numérique) (F)
Une routine de comparaison pour C<sort> doit retourner un nombre.
Vous l'avez probablement foutu en l'air en n'utilisant pas C<< <=> >>
ou C<cmp>, ou en ne les utilisant pas correctement.
Cf. L<perlfunc/sort>.

=item Sort subroutine didn't return single value

(Le sous-programme de C<sort> n'a pas renvoyé une valeur unique) (F)
Une routine de comparaison pour C<sort> ne peut pas renvoyer une
valeur de liste avec plus ou moins d'un élément. Cf. L<perlfunc/sort>.

#if defined(perldiag580) or defined(perldiag573)
=item splice() offset past end of array

(Le décalage pour C<splice> est en dehors du tableau) (W misc) Vous
avez tenté de spécifier un décalage au-delà de la fin du tableau lors
de l'appel à C<splice>. La fonction commencera à la fin du tableau au
lieu de commencer au-delà. Si ce n'est pas ce que vous voulez, essayez
d'agrandir explicitement votre tableau en alimentant C<$#tableau> avec
C<$decalage>. Cf. L<perlfunc/splice>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Split loop

(Boucle dans un C<split>) (P) Le C<split> bouclait sans fin. (De
toute évidence, un C<split> ne devrait boucler plus de fois qu'il n'y
a de caractères en entrée, c'est pourtant qui s'est passé.)
Cf. L<perlfunc/split>.

#endif
#if defined(perldiag560)
=item Split loop

(Boucle dans un C<split>) (P) Le C<split> bouclait sans fin.
('Evidemment, un C<split> ne devrait boucler plus de fois qu'il n'y a
de caractères en entrée, ce qui s'est passé.) 

#endif
=item Statement unlikely to be reached

(Instruction peu susceptible d'être atteinte) (W exec) Vous avez fait
un C<exec> avec des instructions le suivant autres qu'un C<die>. Il
s'agit presque toujours d'une erreur car C<exec> ne revient jamais à
moins qu'il n'y ait une erreur. Vous vouliez probablement utiliser
C<system> à la place, qui lui revient. Pour supprimer cet
avertissement, mettez le C<exec> dans un bloc tout seul. 

#if defined(perldiag560)
=item Stat on unopened file <%s>

(C<stat> sur un fichier non ouvert <I<%s>>) (W unopened) Vous avez
essayé d'utiliser la fonction C<stat> (ou un test de fichier
équivalent) sur un handle de fichier qui n'a jamais été ouvert ou qui
a été fermé depuis. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item stat() on unopened filehandle %s

(C<stat()> sur un handle de fichier non ouvert) (W unopened) Vous avez
essayé d'utiliser la fonction C<stat> sur un handle de
fichier qui soit n'a jamais été ouvert, soit a été fermé depuis. 

#endif
#if defined(perldiag560)
=item Strange *+?{} on zero-length expression

(C<*+?{}> étrange sur une expression de longueur nulle) (W regexp)
Vous avez appliqué un quantifiant d'expression régulière à un endroit
où cela n'a aucun sens, comme dans une assertion de longueur nulle.
Essayez de plutôt mettre le quantifiant à l'intérieur de l'assertion.
Par exemple, le moyen de réussir la correspondance avec C<abc>, si
c'est suivi par trois répétitions de C<xyz> est
C</abc(?=(?:xyz){3})/>, et non C</abc(?=xyz){3}/>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Stub found while resolving method `%s' overloading %s

(Une souche a été trouvée lors de la résolution de la méthode 'I<%s>'
surchargeant I<%s>) (P) La résolution de la surcharge en parcourant
l'arborescence C<@ISA> peut se planter à cause de souches
d'importation. Les souches ne devraient jamais être créées
implicitement, mais des appels explicites à C<can> peuvent casser la
mécanique.

#endif
#if defined(perldiag560)
=item Stub found while resolving method `%s' overloading `%s' in package `%s'

(Souche trouvée lors de la résolution de la méthode `I<%s>'
surchargeant `I<%s>' dans le paquetage `I<%s>') (P) La résolution de
la surcharge dans l'arbre C<@ISA> a peut être été rompue par des
souches (I<stubs>) d'importation. Les souches ne devraient jamais
être implicitement créées mais les appels explicites à C<can> peuvent
rompre cela. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Subroutine %s redefined

(Sous-programme I<%s> redéfini) (W redefine) Vous avez redéfini un
sous-programme. Pour supprimer cet avertissement, écrivez :

  {
      no warnings 'redefine';
      eval "sub name { ... }";
  }

#endif
#if defined(perldiag560)
=item Subroutine %s redefined

(Sous-programme I<%s> redéfini) (W redefine) Vous avez redéfini un
sous-programme. Pour supprimer cet avertissement, écrivez :

  {
      no warnings;
      eval "sub name { ... }";
  }

#endif
#if defined(perldiag560)
=item Substitution loop

(Boucle dans une substitution) (P) La substitution boucle sans fin.
('Evidemment, une substitution ne devrait boucler plus de fois qu'il
n'y a de caractères en entrée, ce qui s'est passé.) 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Substitution loop

(Boucle dans une substitution) (P) La substitution boucle sans fin. Il
est évident qu'une substitution ne devrait boucler plus
de fois qu'il n'y a de caractères  en entrée.
Pourtant, c'est ce qui s'est produit. Cf. la discussion sur la
substitution dans L<perlop/"Quote and Quote-like Operators">.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Substitution pattern not terminated

(Motif pour la substitution non terminé) (F) L'analyseur lexical ne
peut trouver le délimiteur intérieur d'une construction C<s///> ou
C<s{}{}>. Souvenez-vous que les délimiteurs fonctionnant par paires 
« ouvrant/fermant » (tels que les parenthèses, les crochets, les
accolades ou les signes inférieur/supérieur) comptent les niveaux
d'imbrication. Omettre le C<$> au début d'une variable C<$s> peut
causer cette erreur.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Substitution replacement not terminated

(Remplacement pour la substitution non terminé) (F) L'analyseur
lexical ne peut trouver le délimiteur final d'une construction
C<s///> ou C<s{}{}>. Souvenez-vous que les délimiteurs fonctionnant
par paires « ouvrant/fermant » (tels que les parenthèses, les
crochets, les accolades ou les signes inférieur/supérieur) comptent
les niveaux d'imbrication. Omettre le C<$> au début d'une variable C<$s>
peut causer cette erreur. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item substr outside of string

(C<substr> à l'extérieur d'une chaîne) (W substr|F) Vous avez essayé
de référencer un C<substr> qui pointait en dehors d'une chaîne.
C'est-à-dire que la valeur absolue du décalage est plus grande que la
longueur de la chaîne. Cet avertissement est fatal si C<substr> est
utilisé dans un contexte de lvalue (par exemple comme opérateur du
côté gauche d'une affectation ou comme argument d'un sous-programme). 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item suidperl is no longer needed since %s

(suidperl n'est plus nécessaire depuis I<%s>) (F) Votre Perl a été
compilé avec B<-DSETUID_SCRIPTS_ARE_SECURE_NOW> mais une version de
l'émulateur setuid est tout de même arrivé à se lancer d'une manière
ou d'une autre. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Switch (?(condition)... contains too many branches in regex;

marked by <-- HERE in m/%s/

(L'alternative C<(?(condition)...> contient trop de branches dans l'expression
rationnelle) (F) Une construction C<(?(condition)clause-si-vrai|clause-si-faux)>
comporte au maximum deux branches (la clause-si-vrai et la clause-si-faux).
Si vous voulez qu'une de ces deux clauses comporte une disjonction (un ou, comme
C<ceci|cela|autre>, utilisez des parenthèses de groupement :

    (?(condition)(?:ceci|cela|autre)|clause-si-faux)

La mention « <-- HERE » indique l'endroit où le problème a été constaté.
Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Switch condition not recognized in regex;

marked by <-- HERE in m/%s/

(L'alternative n'est pas reconnue dans l'expression rationnelle) (F) Si 
l'argument d'une construction C<(?(condition)clause-si-vrai|clause-si-faux)> 
est un nombre, cela peut seulement être un nombre. La mention « <--
HERE » indique l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
=item switching effective %s is not implemented

(l'échange de I<%s> effectif n'est pas implémenté) (F) Avec le pragma
C<use filetest> actif, nous ne pouvons pas échanger les UID ou les
GID réels et effectifs. 

=item syntax error

(erreur de syntaxe) (F) Ce message veut probablement dire que vous
avez eu une erreur de syntaxe. Les raisons habituelles incluent: 

    Un mot clef est mal orthographié.
    Il manque un point-virgule.
    Il manque une virgule.
    Il manque une parenthèse ouvrante ou fermante.
    Il manque un crochet ouvrant ou fermant.
    Il manque une apostrophe ou un guillemet fermant.

Souvent un autre message sera associé avec l'erreur de syntaxe
donnant plus d'informations. (Parfois, cela aide d'activer B<-w>.) Le
message d'erreur en lui-même dit souvent à quel endroit de la ligne
Perl a décider de s'arrêter. Parfois la véritable erreur se trouve
quelque tokens avant car Perl est doué pour comprendre ce que l'on
entre aléatoirement. Occasionnellement, le numéro de ligne peut être
inexact et la seule manière de savoir ce qui ce passe est d'appeler
de façon répétitive, une fois tous les 36 du mois, I<perl -c> en
éliminant à chaque fois la moitié du programme pour voir où l'erreur
disparaît. Il s'agit d'une sorte de version cybernétique du jeu des
20 questions.

=item syntax error at line %d: `%s' unexpected

(erreur de syntaxe à la ligne I<%d> : `I<%s>' inattendu) (A) Vous
avez accidentellement lancé votre script via le Bourne shell au lieu
de Perl. Vérifiez la ligne C<#!> ou lancez vous-même votre script
manuellement dans Perl avec I<perl nom_script>. 

#if defined(perldiag580) or defined(perldiag573)
=item syntax error in file %s at line %d, next 2 tokens "%s"

(Erreur de syntaxe dans le fichier I<%s> à la ligne I<%d>, près des
deux tokens "I<%s>") (F) Cette erreur est susceptible d'apparaître si vous
soumettez un script Perl-5 à un interprêteur Perl-4, surtout si les deux
tokens signalés sont "use strict", "my $var" ou "our $var".

#endif
=item %s syntax OK

(I<%s> syntaxe OK) (F) Message final lorsqu'un I<perl -c> a réussi. 

#if defined(perldiag580) or defined(perldiag573)
=item System V %s is not implemented on this machine

(I<%s> de System V n'est pas implémenté sur cette machine) (F) Vous
avez essayé de faire quelque chose avec une fonction commençant par
C<sem>, C<shm> ou C<msg> mais cet IPC System V n'est pas implémenté
sur votre machine. (Sur certaines machines, la fonctionnalité peut
exister mais peut ne pas être configurée.) Adressez-vous à votre 
support système.

#endif
#if defined(perldiag560)
=item System V %s is not implemented on this machine

(I<%s> de System V n'est pas implémenté sur cette machine) (F) Vous
avez essayé de faire quelque chose avec une fonction commençant par
C<sem>, C<shm> ou C<msg> mais cet IPC System V n'est pas implémenté
sur votre machine. (Sur certaines machines, la fonctionnalité peut
exister mais peut ne pas être configurée.) 

#endif
=item syswrite() on closed filehandle %s

(C<syswrite()> sur un handle de fichier fermé) (W closed) Le handle
de fichier dans lequel vous écrivez s'est retrouvé fermé à un moment
auparavant. Vérifiez le flux logique de votre programme. 

=item Target of goto is too deeply nested

(La cible du C<goto> est imbriquée trop profondément) (F) Vous avez
essayé d'utiliser C<goto> pour atteindre une étiquette qui était trop
profondément imbriquée pour que Perl puisse l'atteindre. Perl vous
fait une faveur en vous le refusant. 

#if defined(perldiag560)
=item tell() on unopened file

(C<tell()> sur un fichier non ouvert) (W unopened) Vous avez essayé
d'utiliser la fonction C<tell()> sur un handle de fichier qui n'a
jamais été ouvert ou qui a été fermé depuis. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item tell() on unopened filehandle

(C<tell> sur un handle de fichier non ouvert) (W unopened) Vous avez
tenté d'utiliser la fonction C<tell> sur un handle de fichier qui n'a 
jamais été ouvert, ou bien qui a été fermé.

#endif
#if defined(perldiag560)
=item Test on unopened file <%s>

(Test sur un fichier non ouvert I<%s>) (W unopened) Vous avez essayé
d'invoquer un opérateur de test de fichier sur un handle de fichier
qui n'est pas ouvert. Vérifiez votre logique. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item That use of $[ is unsupported

(Cette utilisation de C<$[> n'est pas supportée) (F) L'affectation de
C<$[> est maintenant strictement circonscrite et interprétée comme
une directive de compilation. Vous devez maintenant écrire une seule
possibilité parmi celles-ci :

  $[ = 0;
  $[ = 1;
  ...
  local $[ = 0;
  local $[ = 1;
  ...

Ceci est imposé pour prévenir le problème d'un module changeant par inadvertance la
base des tableaux pour un autre module. Cf. L<perlvar/$[>.

#endif
#if defined(perldiag560)
=item That use of $[ is unsupported

(Cette utilisation de $[ n'est pas supportée) (F) L'affectation de
C<$[> est maintenant strictement circonscrite et interprétée comme
une directive de compilation. Vous devez maintenant écrire une seule
possibilité parmi celles-ci :

  $[ = 0;
  $[ = 1;
  ...
  local $[ = 0;
  local $[ = 1;
  ...


Ceci est imposé pour prévenir le problème d'un module changeant la
base des tableaux depuis un autre module par inadvertance.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item The crypt() function is unimplemented due to excessive paranoia

(La fonction C<crypt()> n'est pas implémentée à cause d'une paranoïa
excessive) (F) I<Configure> n'a pas pu trouver la fonction C<crypt> sur 
votre machine, probablement parce que votre fournisseur ne l'a
pas fournie, probablement parce qu'il pense que le gouvernement des États-Unis
d'Amérique pense que c'est un secret ou du moins continue à prétendre que 
c'en est un. Et si vous me citez comme source, j'opposerai un démenti.

#endif
#if defined(perldiag560)
=item The crypt() function is unimplemented due to excessive paranoia

(La fonction C<crypt()> n'est pas implémentée à cause d'une paranoïa
excessive) (F) I<Configure> n'a pas pu trouver la fonction C<crypt>
sur votre machine, probablement parce que votre vendeur ne l'a pas
fournie, probablement parce qu'il pense que le gouvernement des
États-Unis pense que c'est un secret ou du moins continue à prétendre
que c'en est un. 

#endif
=item The %s function is unimplemented

(La fonction I<%s> n'est pas implémentée) La fonction indiquée n'est
pas implémentée sur cette architecture, selon les tests de
I<Configure>. 

#if defined(perldiag560)
=item The stat preceding C<-l _> wasn't an lstat

(Le C<stat> précédant C<-l _> n'était pas un C<lstat>) (F) Cela n'a
pas de sens de vérifier si le tampon courant de C<stat> est un lien
symbolique si le dernier stat que vous avez écrit dans le tampon a
déjà passé le lien symbolique pour obtenir le fichier réel. Utilisez
un véritable nom de fichier à la place. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item The stat preceding %s wasn't an lstat

(Le C<stat> précédent n'était pas un C<lstat>) (F) Cela n'a aucun sens
de tester le tampon de C<stat> pour vérifier si c'est un lien symbolique,
si le dernier C<stat> qui a écrit dans ce tampon est déjà passé par le
lien symbolique pour obtenir le fichier réel. Utilisez le nom du fichier
à la place.

#endif
#if defined(perldiag560)
=item This Perl can't reset CRTL environ elements (%s)

(Cette copie de Perl ne peut pas réinitialiser les éléments de
l'environnement de CRTL (I<%s>)) 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item This Perl can't reset CRTL environ elements (%s)

(Cette version de Perl ne peut pas réinitialiser les éléments de
l'environnement de CRTL (I<%s>)) (W internal) C'est un avertissement
spécifique à VMS. Vous avez essayé de supprimer un élément du tableau
interne de l'environnement CRTL, mais votre version de Perl n'a pas
été construite avec un CRTL comportant la fonction C<setenv>. Vous
allez être obligé de reconstruire Perl avec un CTRL muni de C<setenv>,
ou bien redéfinir F<PERL_ENV_TABLES> (Cf. L<perlvms>) de sorte que le
tableau d'environnement ne sera pas la cible des modifications à
C<%ENV>, modifications qui ont déclenché l'avertissement.

#endif
#if defined(perldiag560)
=item This Perl can't set CRTL environ elements (%s = %s)

(Cette copie de Perl ne peut pas positionner les éléments de
l'environnement de CRTL (I<%s> C<=> I<%s>)) (W internal) Il s'agit
d'avertissements spécifiques à VMS. Vous avez essayé de modifier ou
de supprimer un élément du tableau d'environnement interne de CRTL
mais votre copie de Perl n'a pas été compilée avec un CRTL contenant
la fonction interne C<setenv>. Vous devrez recompiler Perl avec un
CRTL qui le contienne ou redéfinir C<PERL_ENV_TABLES> (voir
I<perlvms>(1)) pour que le tableau d'environnement ne soit pas la
cible de la modification de C<%ENV> qui a produit cet avertissement. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item This Perl can't set CRTL environ elements (%s=%s)

(Cette version de Perl ne peut pas alimenter les éléments de
l'environnement CRTL (I<%s>)) (W internal) C'est un avertissement
spécifique à VMS. Vous avez essayé de modifier un élément du tableau
interne de l'environnement CRTL, mais votre version de Perl n'a pas
été construite avec un CRTL comportant la fonction C<setenv>. Vous
allez être obligé de reconstruire Perl avec un CTRL muni de C<setenv>,
ou bien redéfinir F<PERL_ENV_TABLES> (Cf. L<perlvms>) de sorte que le
tableau d'environnement ne sera pas la cible des modifications à
C<%ENV>, modifications qui ont déclenché l'avertissement.

#endif
#if defined(perldiag580)
=item thread failed to start: %s

(F) The entry point function of threads->create() failed for some reason.

#endif
=item times not implemented

(C<times> non implémenté) (F) Votre version de la bibliothèque C ne
fait apparemment pas de C<times>. Je suspecte que vous n'êtes pas
sous Unix. 

=item Too few args to syscall

(Trop peu d'arguments pour C<syscall>) (F) Il doit y avoir au moins
un argument à C<syscall> pour spécifier l'appel système à appeler,
pauvre étourdi ! 

=item Too late for "B<-T>" option

(Trop tard pour l'option «B<-T>») (X) La ligne C<#!> (ou son
équivalent local) dans un script Perl contient l'option B<-T> mais
Perl n'a pas été invoqué avec B<-T> sur la ligne de commande. Il
s'agit d'une erreur car le temps que Perl découvre un B<-T> dans un
script, il est trop tard pour marquer proprement l'intégralité de
l'environnement. Donc Perl abandonne.

Si le script Perl a été exécuté en tant que commande en utilisant le
mécanisme C<#!> (ou son équivalent local), cette erreur peut
habituellement être corrigée en éditant la ligne C<#!> pour que
l'option B<-T> fasse partie du premier argument de Perl : ex. changer
C<perl -n -T> en C<perl -T -n>.

Si le script Perl a été exécuté en tant que I<perl nom_script> alors
l'option B<-T> doit apparaître sur la ligne de commande : I<perl -T
nom_script>.

=item Too late for "-%s" option

(Trop tard pour l'option « B<->B<< I<%s> >> ») (X) La ligne C<#!> (ou
son équivalent local) dans un script Perl contient l'option B<-M> ou
B<-m>. Il s'agit d' une erreur car les options B<-M> et B<-m> ne sont
pas prévues pour être utilisées à l'intérieur des scripts. Utilisez le
pragma C<use> à la place.

#if defined(perldiag560)
=item Too late to run %s block

(Trop tard pour lancer le bloc I<%s>) (W void) Un bloc C<CHECK> ou
C<INIT> a été défini à l'exécution, lorsque l'opportunité de le
lancer est déjà passée. Vous chargez peut-être un fichier avec
C<require> ou C<do> alors que vous devriez utiliser C<use> à la
place. Ou vous devriez peut-être mettre le C<require> ou le C<do> à
l'intérieur d'un bloc C<BEGIN>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Too late to run %s block

(Trop tard pour lancer le bloc I<%s>) (W void) Votre programme définit
un bloc C<CHECK> ou C<INIT> à la phase d'exécution à proprement
parler, alors que le moment où ils devraient être exécutés est déjà
passe. Peut-être avez-vous chargé un fichier par C<require> ou par
C<do>, alors que vous auriez dû le charger par C<use>. Ou peut-être
vaut-il mieux insérer le C<require> ou le C<do> dans un bloc C<BEGIN>.

#endif
=item Too many args to syscall

(Trop d'arguments pour C<syscall>) (F) Perl admet 14
arguments au maximum pour C<syscall>. 

=item Too many arguments for %s

(Trop d'arguments pour I<%s>) (F) La fonction demande moins
d'arguments que  vous en avez spécifié.

=item Too many ('s

(Trop de « C<(> »)  (A) Vous avez lancé accidentellement votre script
via I<csh> au lieu de Perl. Vérifiez la ligne C<#!> ou lancez
vous-même votre script manuellement dans Perl avec I<perl
nom_script>. 

=item Too many )'s

(Trop de « C<)> ») (A) Vous avez lancé accidentellement votre script
via I<csh> au lieu de le soumettre à Perl. Vérifiez la ligne C<#!> ou
lancez vous-même votre script manuellement dans Perl avec I<perl
nom_script>.

#if defined(perldiag580) or defined(perldiag573)
=item Trailing \ in regex m/%s/

(\ à la fin de l'expression rationnelle C<m/>I<%s>C</>) (F)
L'expression rationnelle se termine avec un antislash qui n'est pas
antislashé. Prière de l'antislasher. Cf. L<perlre>.

#endif
#if defined(perldiag560)
=item trailing \ in regexp

(C<\> à la fin de l'expression régulière) (F) L'expression régulière
se termine par un antislash qui n'est pas protégé par un antislash.
Faites-le. 

#endif
=item Transliteration pattern not terminated

(Motif pour la traduction non terminé) (F) L'analyseur lexical n'a
pas pu trouver le délimiteur intérieur d'une construction C<tr///>,
C<tr[][]>, C<y///> ou C<y[][]>. Omettre le C<$> au début des
variables C<$tr> ou C<$y> peut causer cette erreur. 

=item Transliteration replacement not terminated

(Remplacement pour la traduction non terminé) (F) L'analyseur lexical
n'a pas pu trouver le délimiteur final d'une construction C<tr///> ou
C<tr[][]>. 

#if defined(perldiag561) or defined(perldiag560)
=item truncate not implemented

(C<truncate> non implémenté) (F) Votre machine n'implémente pas de
mécanisme de troncation de fichier que I<Configure> puisse
reconnaître. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item truncate not implemented

(C<truncate> n'est pas implémenté) (F) Votre machine n'implémente pas
de mécanisme de troncation de fichier que I<Configure> puisse
reconnaître. 

#endif
=item Type of arg %d to %s must be %s (not %s)

(Le type de l'argument I<%d> de I<%s> doit être I<%s> (pas I<%s>)) (F)
Cette fonction exige que l'argument à cette position soit d'un certain
type. Les tableaux doivent être C<@>I<NOM> ou C<@{>I<EXPR>C<}>. Les
hachages doivent être C<%>I<NOM> ou C<%{>I<EXPR>C<}>. Aucun
déréférencement implicite n'est permis --- utilisez la forme
C<{>I<EXPR>C<}> en tant que déréférencement explicite.
Cf. L<perlref>.

#if defined(perldiag560)
=item umask: argument is missing initial 0

(C<umask> : il manque C<0> au début de l'argument) (W umask) Un umask
de C<222> est incorrect. Il devrait être C<0222> car les littéraux
octaux commencent toujours par C<0> en Perl, tout comme en C. 

#endif
=item umask not implemented

(C<umask> non implémenté) (F) Votre machine n'implémente pas la
fonction C<umask> et vous avez essayé de l'utiliser pour restreindre
les permissions pour vous-même. (I<EXPR> C<& 0700>). 

=item Unable to create sub named "%s"

(Impossible de créer le sous-programme nommé « I<%s> ») (F) Vous avez
tenté de créer ou d'invoquer un sous-programme avec un nom illégal.

=item Unbalanced context: %d more PUSHes than POPs

(Contexte déséquilibré : I<%d> C<PUSH> de plus que de C<POP>) (W
internal) Le code de sortie a détecté une incohérence interne entre
le nombre de contextes d'exécution dans lesquels on est entré et
depuis lesquels on est sorti. 

=item Unbalanced saves: %d more saves than restores

(Sauvegardes déséquilibrées : I<%d> sauvegardes de plus que de
restaurations) (W internal) Le code de sortie a détecté une
incohérence interne entre le nombre de variables qui ont été
sauvegardées par C<local>. 

=item Unbalanced scopes: %d more ENTERs than LEAVEs

(Portées déséquilibrées : I<%d> C<ENTER> de plus que de C<LEAVE>) (W
internal) Le code de sortie a détecté une incohérence interne entre
le nombre de blocs dans lequel on est rentré et depuis lesquels on
est sorti. 

=item Unbalanced tmps: %d more allocs than frees

(Déséquilibre de valeurs temporaires : I<%d> allouées de plus que de
libérées) (W internal) Le code de sortie a détecté une incohérence
interne entre le nombre de scalaires mortels qui ont été alloués et
libérés. 

=item Undefined format "%s" called

(Format indéfini « I<%s> » appelé) (F) Le format indiqué ne semble
pas exister. Peut-être est-il réellement dans un autre paquetage ? 
Cf. L<perlform>.

=item Undefined sort subroutine "%s" called

(Sous-programme de C<sort> indéfini« I<%s> » ) (F) La routine de
comparaison de C<sort> spécifiée ne semble pas exister. Peut-être se
trouve-t-elle dans un autre paquetage ?  Cf. L<perlfunc/sort>.

=item Undefined subroutine &%s called

(Appel du sous-programme indéfini C<&>I<%s>) (F) Le sous-programme
indiqué n'a pas été défini Ou  s'il l'a été, sa définition a été
annulée par la suite.

=item Undefined subroutine called

(Appel d'un sous-programme indéfini) (F) Le sous-programme anonyme que
vous essayez d'appeler n'a pas été défini Ou  s'il l'a été, sa
définition a été annulée par la suite.

=item Undefined subroutine in sort

(Sous-programme indéfini dans C<sort>) (F) La routine de comparaison
de C<sort> spécifiée est déclarée mais ne semble pas avoir été définie
pour le moment. Cf. L<perlfunc/sort>.

=item Undefined top format "%s" called

(Appel d'un format d'en-tête « I<%s> » indéfini) (F) Le format
indiqué  ne semble pas exister. Peut-être existe-t-il dans un autre
paquetage ?  Cf. L<perlform>.

=item Undefined value assigned to typeglob

(Valeur indéfinie affectée à un typeglob) (W misc) Une valeur
indéfinie a été affectée à un typeglob, comme C<*truc = undef>. Cela
n'a aucun effet. Il est possible que vous vouliez dire en réalité
C<undef *truc>. 

=item %s: Undefined variable

(I<%s> : Variable indéfinie ) (A) Vous avez lancé accidentellement
votre script avec I<csh> au lieu de Perl. Vérifiez la ligne avec
C<#!> ou lancez vous-même votre script manuellement dans Perl avec
I<perl nom_script>. 

=item unexec of %s into %s failed!

(Échec de l'C<unexec> de I<%s> dans I<%s> !) (F) La routine
C<unexec> a échoué pour une raison ou pour une autre. Voir votre
représentant local FSF (I<Free Software Fondation>), qui l'a
probablement mis là en premier lieu. 

#if defined(perldiag580) or defined(perldiag573)
=item Unicode character %s is illegal

(Le caractère Unicode I<%s> est illégal) (W utf8) Certains caractères
Unicode ont été déclarés hors domaine de validité et ne devraient pas
être générés. Si vous savez bien ce que vous faites, vous pouvez
supprimer cet avertissement avec C<no warnings 'utf8';>.

#endif
=item Unknown BYTEORDER

(C<BYTEORDER> inconnu) (F) Il n'y a aucune fonction d'échange
d'octets pour une machine fonctionnant avec cet ordre d'octets. 

#if defined(perldiag580)
=item Unknown open() mode '%s'

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.

#endif
=item Unknown open() mode '%s'

(Mode d'C<open()> 'I<%s>' inconnu) (F) Le deuxième argument d'un
C<open> à trois arguments n'est pas dans la liste des modes valides :
C<< < >>, C<< > >>, C<< >> >>, C<< +< >>, C<< +> >>, C<< +>> >>,
C<-|>, C<|->. 

=item Unknown process %x sent message to prime_env_iter: %s

(Le processus inconnu I<%x> a envoyé un message au C<prime_env_iter> : 
I<%s>) (P) Il s'agit d'une erreur spécifique à VMS. Perl lisait des
valeurs pour C<%ENV> avant de le parcourir et quelqu'un d'autre a
collé un message dans le flux de données que Perl attendait.
Quelqu'un de très perturbé ou peut-être essayant de subvertir le
contenu de C<%ENV> pour Perl dans un but néfaste. 

#if defined(perldiag573)
=item Unknown "re" subpragma '%s' (known ones are: %s)

(Sous-pragma « I<%s> » inconnu pour « re » (les sous-pragmas connus
sont I<%s>)) Vous avez essayé d'utiliser un sous-pragma inconnu pour
le pragma « re ».

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unknown switch condition (?(%.2s in regex;

marked by <-- HERE in m/%s/

(Condition de test d'expression rationnelle inconnue) (F) La partie
condition d'une construction C<(?(condition)si-vrai|si-faux)> n'est
pas connue. La condition peut être un test en avant ou en arrière (la
condition est vraie si l'assertion lookahead ou lookbehind est
vérifiée), une construction C<(?{...}> (la condition est vraie si
l'évaluation du code renvoie une valeur « vrai » ou un nombre (la
condition est vraie si la paire de parenthèses de capture
correspondant à ce nombre a obtenu une correspondance). La mention 
« <-- HERE » indique l'endroit où le problème a été constaté. Cf
L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unknown warnings category '%s'

(Catégorie d'avertissements « I<%s> » inconnue)
(F) Erreur produite par le pragma C<warnings>. Vous avez spécifié une
catégorie d'avertissement inconnue de perl à cet endroit.

À noter que si vous voulez activer une catégorie d'avertissement
répertoriée dans un module (par exemple C<use warnings 'File::Find'>),
il faut avoir importé ce module au préalable.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item unmatched ( in regex; marked by <-- HERE in m/%s/

(« C<(> » sans correspondant dans une expression rationnelle) (F) Les
parenthèses figurant dans une expression rationnelle doivent être
équilibrées. Si vous utilisez vi, la touche « % » est précieuse pour
trouver les correspondances de parenthèses. La mention « <-- HERE »
indique l'endroit où le problème a été constaté. Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item unmatched [ in regex; marked by <-- HERE in m/%s/

(« C<[> » sans correspondant dans une expression rationnelle) (F) Les
crochets figurant dans une expression rationnelle doivent être
équilibrés. Si vous voulez inclure un crochet dans une classe de
caractères, antislashez-le ou faites le figurer en première
position. La mention « <-- HERE » indique l'endroit où le problème a
été constaté. Cf L<perlre>.

#endif
#if defined(perldiag560)
=item unmatched () in regexp

(C<()> sans correspondance dans l'expression régulière) (F) Les
parenthèses non protégées par un anti-slash doivent toujours être
équilibrées dans les expressions régulières. Si vous êtes utilisateur
de I<vi>, la touche C<%> est parfaitement adaptée pour trouver la
parenthèse correspondante. 

#endif
#if defined(perldiag560)
=item unmatched [] in regexp

([] sans correspondance dans l'expression régulière) (F) Les crochets
autour d'une classe de caractères doivent se correspondre. Si vous
voulez inclure un crochet fermant dans une classe de caractères,
protégez le avec un antislash ou mettez le en premier. 

#endif
=item Unmatched right %s bracket

(Signe I<%s> fermant sans correspondance) (F) L'analyseur lexical a
compté plus d'accolades ou de crochets fermants que d'ouvrants, vous
avez donc probablement oublié de mettre un caractère ouvrant
correspondant. En règle générale, vous trouverez le caractère introuvable
(si l'on peut s'exprimer ainsi) près de l'endroit où vous étiez en
train d'éditer en dernier. 

#if defined(perldiag560)
=item Unquoted string "%s" may clash with future reserved word

(Chaîne sans guillemets ni apostrophes « I<%s> » susceptible d'être
en conflit avec un mot réservé dans le futur) (W reserved) Vous
utilisez un mot simple qui pourrait être un jour proclamé comme étant
un mot réservé. Le mieux est de mettre un tel mot entre guillemets ou
entre apostrophes ou en lettres capitales ou d'insérer un souligné
dans son nom. Vous pouvez également le déclarer en tant que
sous-programme. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unquoted string "%s" may clash with future reserved word

(Chaîne sans guillemets ni apostrophes « I<%s> » susceptible d'être
en conflit avec un mot réservé dans le futur) (W reserved) Vous
utilisez un mot simple qui pourrait être un jour proclamé comme étant
un mot réservé. Le mieux est de mettre un tel mot entre guillemets ou
entre apostrophes, de lui attribuer au moins une majuscule, ou d'y
insérer un blanc souligné. Vous pouvez également le déclarer en tant
que sous-programme.

#endif
=item Unrecognized character %s

(Caractère I<%s> non reconnu) (F) L'analyseur syntaxique de Perl ne
sait absolument pas quoi faire avec le caractère spécifié dans votre
script Perl (ou dans la chaîne traitée par C<eval>). Peut-être
avez-vous essayé de lancer un script compressé, un programme binaire
ou un répertoire en tant que programme Perl.

=item /%s/: Unrecognized escape \\%c in character class passed through

(C</>I<%s>C</> : Rencontre d'une séquence d'échappement C<\\>I<%c>
inconnue dans une classe de caractères) (W regexp) Vous avez employé
une combinaison avec un caractère antislash qui n'est pas reconnue
par Perl à l'intérieur d'une classe de caractères. Le caractère a été
interprété littéralement. 

#if defined(perldiag560)
=item /%s/: Unrecognized escape \\%c passed through

(C</>I<%s>C</> : Rencontre d'une séquence d'échappement C<\\>I<%c>
inconnue) (W regexp) Vous avez employé une combinaison avec un
caractère antislash qui n'est pas reconnue par Perl. Cette
combinaison apparaît dans une variable interpolée ou une expression
régulière délimitée par C<'>. Le caractère a été interprété
littéralement. 

#endif
=item Unrecognized escape \\%c passed through

(Rencontre d'une séquence d'échappement C<\\>I<%c> inconnue) (W
misc) Vous avez employé une combinaison avec un caractère antislash
qui n'est pas reconnue. 

#if defined(perldiag580) or defined(perldiag573)
=item Unrecognized escape \\%c passed through in regex;

marked by <-- HERE in m/%s/

(Séquence d'échappement C<\\>I<%c> passée telle quelle dans
l'expression régulière) (W regexp) Vous avez employé une combinaison
avec un caractère antislash qui n'est pas reconnue par Perl. Cette
combinaison apparaît dans une variable interpolée ou une expression
régulière délimitée par C<'>. Le caractère a été interprété
littéralement. La mention « <-- HERE » indique l'endroit où la
séquence a été recontrée.

#endif
=item Unrecognized signal name "%s"

(Nom de signal « I<%s> » non reconnu) (F) Vous avez spécifié un nom
de signal à la fonction C<kill> qui n'est pas reconnue. Faites C<kill
-l> dans votre shell pour voir les noms de signaux valides sur votre
système. 

=item Unrecognized switch: -%s  (-h will show valid options)

(Option inconnue : B<->B<< I<%s> >> (B<-h> donne les options
valides)) (F) Vous avez spécifié une option illégale pour Perl. Ne
faites pas cela. (Si vous pensez ne pas l'avoir fait, vérifiez la
ligne C<#!> pour voir si elle ne spécifie pas la mauvaise option dans
votre dos.) 

=item Unsuccessful %s on filename containing newline

(Échec de I<%s> sur un nom de fichier contenant un saut de ligne) (W
newline) Une opération de fichier a été tentée sur un nom de fichier
et cette opération a échoué, probablement parce que le nom de fichier
contenait un caractère de saut de ligne, probablement parce que vous
avez oublié de le faire sauter par un C<chop> ou un C<chomp>. 
Cf. L<perlfunc/chomp>.

#if defined(perldiag560)
=item Unsupported directory function "%s" called

(Fonction « I<%s> » sur les répertoires non supportée appelée) (F)
Votre machine ne supporte pas C<opendir> et C<readdir>. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unsupported directory function "%s" called

(Appel de la fonction non supportée « I<%s> » sur les répertoires) (F)
Votre machine ne supporte pas C<opendir> et C<readdir>. 

#endif
=item Unsupported function %s

(Fonction I<%s> non supportée) (F) Cette machine n'implémente
apparemment pas la fonction indiquée ou du moins c'est ce que pense
I<Configure>. 

#if defined(perldiag560)
=item Unsupported function fork

(Fonction C<fork> non supportée) (F) Votre version d'exécutable ne
supporte pas le C<fork>. 

Remarquez que sur certains systèmes, comme OS/2, il peut y avoir
différentes versions d'exécutables Perl, certaines d'entre elles
supportent C<fork>, d'autres non. Essayez de changer le nom que vous
utilisez pour appelez Perl en C<perl_>, C<perl__> et ainsi de suite.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unsupported function fork

(Fonction C<fork> non supportée) (F) Votre version d'exécutable ne
supporte pas le C<fork>. 

Remarquez que sous certains systèmes, comme OS/2, il peut exister
plusieurs variantes de l'exécutable Perl, certaines supportant
C<fork>, d'autres non. Essayez de changer le nom que vous utilisez
pour Perl en C<perl_>, C<perl__>et ainsi de suite.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Unsupported script encoding

(Cet encodage de script n'est pas supporté) (F) Votre programme
commence par une marque d'ordre Unicode (Unicode Byte Order Mark, BOM)
en vertu de laquelle votre script utilise un encode Unicode que Perl
ne peut pas lire pour l'instant.

#endif
=item Unsupported socket function "%s" called

(Appel de la fonction « I<%s> » sur les sockets non supportée) (F) Votre
machine ne supporte pas le mécanisme des sockets Berkeley ou du moins
c'est ce que pense I<Configure>. 

=item Unterminated attribute list

(Liste d'attributs non terminée) (F) L'analyseur lexical a trouvé
quelque chose d'autre qu'un identificateur simple au début d'un
attribut et ce n'était pas un point-virgule ni le début d'un bloc.
Peut-être avez-vous terminé trop tôt la liste de paramètres de
l'attribut précédent. Cf. L<attributes>.

=item Unterminated attribute parameter in attribute list

(Paramètre d'attribut non terminé dans une liste d'attributs) (F)
L'analyseur lexical a vu une parenthèse ouvrante lorsqu'il analysait
une liste d'attributs mais n'a pas trouvé la parenthèse fermante
correspondante. Vous devez ajouter (ou enlever) un caractère
antislash pour équilibrer vos parenthèses. 
Cf. L<attributes>.

#if defined(perldiag580) or defined(perldiag573)
=item Unterminated compressed integer

(L'entier compressé n'est pas terminé) (F) L'argument d'un
C<unpack("w",...)> est incompatible avec le format BER des entiers
compressés, et il est impossible de le convertir en entier.
Cf. L<perlfunc/pack>.

#endif
=item Unterminated <> operator

(Opérateur C<< <> >> non terminé) (F) L'analyseur lexical a vu un
signe inférieur à un endroit où il s'attendait à un terme, il
recherche donc le signe supérieur correspondant et ne le trouve pas.
Il y a des chances que vous ayez oublié des parenthèses obligatoires
plus tôt dans la même ligne et vous que pensiez vraiment à un 
C<< < >> signifiant «inférieur à ». 

=item untie attempted while %d inner references still exist

(C<untie> tenté alors que I<%d> références internes existent
toujours) (W untie) Une copie de l'objet renvoyé par C<tie> (ou par
C<tied>) était toujours valide lorsqu'C<untie> a été appelé. 

#if defined(perldiag580) or defined(perldiag573)
=item Useless (?-%s) - don't use /%s modifier in regex;

marked by <-- HERE in m/%s/

(C<(?->I<%s>C<)> inutile, supprimez le modificateur C</>I<%s> de l'expression
rationnelle) (W regexp) Vous avez utilisé un modificateur tel
que C<(?-o)> à l'intérieur d'une expression rationnelle, ce qui
n'a de sens que si le modificateur n'apparaît jamais dans l'expression rationnelle.

    if ($chaine =~ /(?-o)$motif/) { ... }

doit s'écrire

    if ($chaine =~ /$motif/) { ... }

La mention « <-- HERE » indique l'endroit où le problème a été constaté.
Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Useless (?%s) - use /%s modifier in regex;

marked by <-- HERE in m/%s/

(C<(?>I<%s>C<)> inutile, utilisez le modificateur C</>I<%s> dans l'expression
rationnelle) (W regexp) Vous avez utilisé un modificateur tel
que C<(?o)> à l'intérieur d'une expression rationnelle, or ce modificateur
n'a de sens que s'il s'applique à l'expression rationnelle dans son ensemble.

    if ($chaine =~ /(?o)$motif/) { ... }

doit s'écrire

    if ($chaine =~ /$motif/o) { ... }

La mention « <-- HERE » indique l'endroit où le problème a été constaté.
Cf L<perlre>.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Useless use of %s in void context

(Utilisation inutile de I<%s> dans un contexte vide) (W void) Vous
avez effectué quelque chose sans effet de bord, et vous l'avez fait
dans un contexte qui ne fait rien de la valeur de retour, comme une
instruction qui quitte un bloc sans renvoyer de valeur ou comme la
partie gauche d'un opérateur virgule scalaire. Le plus souvent, cela
n'est pas le signe d'une stupidité de votre part, mais de l'échec de
Perl à analyser votre programme dans le sens où vous voudriez. Par
exemple, vous obtiendrez ceci si vous confondez les précédences en C
avec les précédences en Python en écrivant :

  $un, $deux = 1, 2;

alors que vous vouliez dire :

  ($un, $deux) = (1, 2);

Une autre erreur courante est l'utilisation de parenthèses ordinaires
pour construire la référence à une liste, alors vous devriez utiliser
des accolades ou des crochets, par exemple, si vous écrivez :

  $tableau = (1,2);

alors que vous vouliez dire :

  $tableau = [1,2];

Les crochets transforment explicitement une valeur de liste en une
valeur scalaire tandis que les parenthèses ne le font pas. Donc,
lorsqu'une liste entre parenthèses est évaluée dans un contexte
scalaire, la virgule est traitée comme l'opérateur virgule de C, qui
rejette l'argument de gauche, ce qui ne correspond pas à ce que vous souhaitez.
Cf. L<perlref> pour plus d'explications.

Cet avertissement n'est pas déclenché lorsqu'il s'applique à la
constante numérique 0 ou à la constante numérique 1, car elles sont
fréquemment utilisées dans des instructions du genre

    1 while sub_avec_effets_de_bord();

Les constantes chaînes de caractères donnant un « 0 » ou un « 1 » produisent
quand même l'avertissement.

#endif
#if defined(perldiag560)
=item Useless use of %s in void context

(Utilisation inutile de I<%s> dans un contexte vide) (W void) Vous
avez fait quelque chose sans effet de bord dans un contexte qui ne
fait rien de la valeur de retour, comme une instruction ne renvoyant
pas de valeur depuis un bloc ou le côté gauche d'un opérateur
scalaire virgule. Par exemple, vous obtiendrez ceci si vous confondez
les précédences en C avec les précédences en Python en écrivant : 

  $un, $deux = 1, 2;

alors que vous vouliez dire :

  ($un, $deux) = (1, 2);

Une autre erreur courante est l'utilisation de parenthèses ordinaires
pour construire une liste de références alors vous devriez utiliser
des accolades ou des crochets, par exemple, si vous écrivez :

  $tableau = (1,2);

alors que vous vouliez dire :

  $tableau = [1,2];

Les crochets transforment explicitement une valeur de liste en une
valeur scalaire tandis que les parenthèses ne le font pas. Donc,
lorsqu'une liste entre parenthèses est évaluée dans un contexte
scalaire, la virgule est traitée comme l'opérateur virgule du C, qui
rejette l'argument de gauche, ce qui n'est pas ce que vous voulez.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Useless use of "re" pragma

(Utilisation inutile du pragma « C<re> ») (W) Vous avez écrit C<use
re;> sans aucun argument. Ceci n'est vraiment pas très utile. 

#endif
#if defined(perldiag560)
=item Useless use of "re" pragma

(Utilisation inutile du pragma « C<re> ») (W) Vous avez fait un C<use
re> sans aucun argument. Ceci n'est vraiment pas très utile. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Useless use of sort in scalar context

(Utilisation inutile du tri en contexte scalaire)
(W void) Vous avez effectué un tri en contexte scalaire, par exemple :

    my $x = sort @y;

Ce n'est pas très utile, et perl optimise votre programme en éliminant
le tri.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Useless use of %s with no values

(Utilisation inutile de I<%s> sans valeurs)
(W syntax) Vous avez utilisé la fonctio C<push()> ou C<unshift()> sans arguments
autre que le tableau, dans le style C<push(@x)> ou C<unshift(@truc)>. 
Cela n'a aucun effet sur le tableau, c'est donc complètement inutile.
En principe, il est possible qu'un C<push(@tableau_lie)> puisse avoir
un effet si le tableau est lié par C<tie> à une classe possédant
une méthode C<PUSH>. Si tel est le cas, vous pouvez écrire
C<push(@tableau_lie, ())> pour éviter l'avertissement.

#endif
=item "use" not allowed in expression

(« C<use> » n'est pas autorisé dans une expression) (F) Le mot-clef
C<use> est reconnu et exécuté à la compilation et il ne renvoie
aucune valeur utile. Cf. L<perlmod>.

=item Use of bare << to mean <<"" is deprecated

(L'utilisation d'un C<< << >> brut signifiant C<< <<"" >> est
dépréciée) (D deprecated) Vous êtes maintenant encouragé à utiliser
la forme explicite avec des guillemets ou des apostrophes si vous
désirez utiliser une ligne vide comme délimiteur final d'un document
« ici-même » (I<N.d.T.> : I<here document>). 

#if defined(perldiag580) or defined(perldiag573)
=item Use of chdir('') or chdir(undef) as chdir() deprecated

(Utilisation de C<chdir('')> ou de C<chdir(undef)> pour C<chdir()> dépréciée)
(D deprecated) Selon la documentation, C<chdir()> sans argument modifie
C<$ENV{HOME}> ou C<$ENV{LOGDIR}>. C<chdir(undef)> et C<chdir('')> 
partagent ce comportement, mais il est déprécié dans leur cas. Dans une
version ultérieure, ils échoueront purement et simplement.

Faites attention à ce que vous passez à C<chdir()>.
Transmettez une valeur définie et différente de blanc, sinon
vous vous retrouverez dans votre répertoire personnel.

#endif
#if defined(perldiag580)
=item Use of /c modifier is meaningless in s///

(W regexp) You used the /c modifier in a substitution.  The /c
modifier is not presently meaningful in substitutions.

#endif
#if defined(perldiag580)
=item Use of /c modifier is meaningless without /g

(W regexp) You used the /c modifier with a regex operand, but didn't
use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Use of *glob{FILEHANDLE} is deprecated

(L'utilisation de C<*glob{FILEHANDLE}> est dépréciée)
(D deprecated) Nous vous encourageons désormais à utiliser la forme
plus concise C<*glob{IO}> pour accéder au handle de fichier dans un typeglob.

#endif
#if defined(perldiag580)
=item Use of /g modifier is meaningless in split

(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.

#endif
#if defined(perldiag560)
=item Use of implicit split to @_ is deprecated

(L'utilisation d'un C<split> implicite sur C<@_> est dépréciée) (D
deprecated) Vous donnez beaucoup de travail au compilateur lorsque
vous écrasez la liste d'arguments d'un sous-programme, il vaut donc
mieux affecter explicitement les résultats d'un C<split> à un tableau
(ou à une liste). 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Use of implicit split to @_ is deprecated

(L'utilisation d'un C<split> implicite sur C<@_> est dépréciée) (D
deprecated) Vous donnez beaucoup de travail au compilateur lorsque
vous écrasez la liste d'arguments d'un sous-programme. Il vaut donc
mieux affecter explicitement les résultats d'un C<split> à un tableau
(ou à une liste).

#endif
=item Use of inherited AUTOLOAD for non-method %s() is deprecated

(L'utilisation de l'héritage par C<AUTOLOAD> pour la non-méthode
I<%s>C<()> est dépréciée) (D deprecated) Comme fonctionnalité (hum)
accidentelle, les sous-programmes AUTOLOAD étaient recherchés de la
même façon que les méthodes (en utilisant la hiérarchie de C<@ISA>)
même lorsque les sous-programmes à auto-charger étaient appelés en
tant que fonctions brutes (ex. : C<Truc::bidule()>) et pas en
tant que méthodes (par exemple, C<< Truc->bidule() >> ou C<<
$obj->bidule() >>). 

Ce bogue a été rectifié dans Perl 5.005, qui utilisait la recherche
de méthodes seulement pour l' C<AUTOLOAD> de méthodes. Cependant, il
y a une base significative de code existant susceptible d'utiliser
l'ancien comportement. Ainsi, en tant qu'étape intermédiaire, Perl
5.004 émettait cet avertissement optionnel quand des non-méthodes
utilisaient des C<AUTOLOAD> héritées.

La règle simple est la suivante : l'héritage ne fonctionnera pas
quand il y a auto-chargement de non-méthodes. La simple correction
pour de l'ancien code est : dans tout module qui avait l'habitude de
dépendre de l'héritage d'C<AUTOLOAD> pour les non-méthodes d'une
classe de base nommée C<Classe_Base>, exécutez C<*AUTOLOAD =
&Classe_Base::AUTOLOAD> au démarrage.

Dans le code qui actuellement fait C<use AutoLoader; @ISA =
qw(AutoLoader);>, vous pouvez supprimer C<AutoLoader> de C<@ISA> et
changer C<use AutoLoader;> en C<use AutoLoader 'AUTOLOAD';>.

=item Use of %s in printf format not supported

(Utilisation de I<%s> non supportée dans un format de C<printf>) (F)
Vous avez essayé d'utiliser une fonctionnalité de C<printf> qui est
accessible en C. Cela veut habituellement dire qu'il existe une
meilleure manière de faire cela en Perl. 

=item Use of $# is deprecated

(L'utilisation de C<$#> est dépréciée) (D deprecated) Il s'agissait
d'une tentative mal avisée d'émuler une fonctionnalité de I<awk> mal
définie. Utilisez plutôt un C<printf> ou un C<sprintf> explicite .

=item Use of $* is deprecated

(L'utilisation de C<$*> est dépréciée) (D deprecated) Cette variable
activait comme par magie la recherche de motifs en multilignes, à la
fois pour vous et pour les sous-programmes malchanceux que vous
seriez amené à appeler. Maintenant, vous devriez utiliser les
modificateurs C<//m> et C<//s> pour faire cela sans les effets
dangereux d'action-à-distance de C<$*>. 

=item Use of %s is deprecated

(L'utilisation de I<%s> est dépréciée) (D deprecated) La construction
indiquée n'est plus recommandée, généralement parce qu'il y a une
meilleure façon de faire et également parce que l'ancienne méthode a
de mauvais effets de bord. 

#if defined(perldiag580) or defined(perldiag573)
=item Use of -l on filehandle %s

(Utilisation de C<-l> sur le handle de fichier I<%s>)
(W io) Un handle de fichier représente un fichier ouvert, et lorsque vous
avez ouvert le fichier en cause, vous avez déjà déréférencé le lien 
symbolique auquel vous vous intéressez. L'opération renvoie C<undef>.
Utilisez plutôt un nom de fichier.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Use of "package" with no arguments is deprecated

(L'utilisation de « C<package> » sans argument est dépréciée)
(D deprecated) Vous avez utilisé le mot-clé C<package> sans indiquer
de nom de paquetage. Il n'y a donc aucun nom de paquetage courant.
En utilisant ceci, des constructions habituellement raisonnables
peuvent planter de façon ahurissante. Utilisez plutôt C<use strict;>.

#endif
#if defined(perldiag573)
=item Use of reference "%s" as array index

(Utilisation de « I<%s> » en tant qu'index de tableau) (W) 
Vous avez tenté d'utiliser une référence pour indexer un tableau.
Ce n'est probablement pas ce que vous avez en tête, parce qu'une
référence évaluée en contexte numérique fournit une valeur 
en général immense, et cela indique habituellement une erreur
du programmeur.

Si vous voulez réellement écrire cela, convertissez votre référence en
nombre de façon explicite par une expression du genre
C<$array[0+$ref]>. Cet avertissement n'est pas non plus émis pour les
objets soumis à une surcharge d'opérateur, car vous pouvez surcharger
les opérateurs de conversion en nombre ou en chaîne, et dans ce cas on
peut supposer que vous savez ce que vous faites.

#endif
#if defined(perldiag580)
=item Use of reference "%s" as array index

(W misc) You tried to use a reference as an array index; this probably
isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.

If you really do mean it, explicitly numify your reference, like so:
C<$array[0+$ref]>.  This warning is not given for overloaded objects,
either, because you can overload the numification and stringification
operators and then you assumedly know what you are doing.

#endif
=item Use of reserved word "%s" is deprecated

(L'utilisation du mot réservé « I<%s> » est dépréciée) (D deprecated)
Le mot simple indiqué est un mot réservé. Les futures versions de
Perl peuvent l'utiliser en tant que mot-clef, vous feriez donc mieux
de mettre explicitement le mot entre guillemets ou entre apostrophes
d'une manière appropriée à son contexte d'utilisation ou d'utiliser
de surcroît un nom différent. L'avertissement peut être supprimé pour
les noms de sous-programmes en ajoutant un préfixe C<&> ou en
qualifiant la variable avec le paquetage, ex. C<&local()>, ou
C<Truc::local()>. 

#if defined(perldiag573)
=item Use of tainted arguments in %s is deprecated

(Utilisation d'arguments marqués dans I<%s> dépréciée) (W taint) Vous
avez transmis plusieurs arguments à C<system()> ou à C<exec()>, et au
moins l'un d'entre eux est marqué. Dans le temps, il était permis de
le faire, mais dans une prochaine version de perl cela sera une erreur
fatale. Supprimez le marquage de vos arguments. Cf. L<perlsec>.

#endif
#if defined(perldiag580)
=item Use of tainted arguments in %s is deprecated

(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple
arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See L<perlsec>.

#endif
#if defined(perldiag560)
=item Use of uninitialized value %s

(Utilisation d'une valeur non initialisée I<%s>) (W uninitialized)
Une valeur indéfinie a été utilisée comme si elle avait déjà été
définie. Elle a été interprétée comme un C<""> ou un C<0> mais
peut-être est-ce une erreur. Pour supprimer cet avertissement,
affectez une valeur définie à vos variables. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Use of uninitialized value%s

(Utilisation de valeurI<%s> non initialiséeI<%s>) (W uninitialized)
Une valeur a été utilisée comme si elle était définie, alors qu'elle
n'était pas définie. Elle a été interprétée comme un C<""> ou un C<0>,
mais c'est peut-être une erreur. Pour supprimer cet avertissement,
assignez une valeur définie à vos variables.

Pour vous faciliter la tâche, perl vous indique quelle opération
faisait référence à la valeur indéfinie. Veuillez noter toutefois que
perl optimise votre programme et que l'opération indiquée n'apparaît
pas nécessairement sous la même forme dans votre programme. Par
exemple, C<"ce $truc"> est en général optimisé en C<"ce " . $truc> et
l'avertissement fera référence à l'opérateur de C<concatenation (.)>,
même s'il n'existe aucun C<.> dans votre programme.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Using a hash as a reference is deprecated

(L'utilisation d'un hachage en tant que référence est dépréciée) (D
deprecated) Vous essayez d'utiliser un hachage en tant que référence,
comme dans C<< %truc->{"machin"} >> or C<< %$ref->{"coucou"} >>. Les
versions de perl antérieures ou égales à 5.6.1 autorisaient cette
syntaxe, mais elles n'auraient pas dû. C'est maintenant une syntaxe
dépréciée et elle disparaîtra d'une prochaine version.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Using an array as a reference is deprecated

(L'utilisation d'un tableau en tant que référence est dépréciée) (D
deprecated) Vous essayez d'utiliser un tableau en tant que référence,
comme dans C<< @truc->[23] >> or C<< %$ref->[99] >>. Les versions de
perl antérieures ou égales à 5.6.1 autorisaient cette syntaxe, mais
elles n'auraient pas dû. C'est maintenant une syntaxe dépréciée et
elle disparaîtra d'une prochaine version.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item UTF-16 surrogate %s

(Séquence de remplacement UTF-16 I<%s>) (W utf8) Vous avez essayé de
générer la moitié d'une séquence de remplacement UTF-16 pour un
caractère Unicode entre les points 0xD800 et 0xDFFF inclus. Cet
intervalle est réservé à l'encodage UTF-16 (en utilisant deux
caractères UCS-2 à 16 bits) ; mais Perl encode ses caractères en
UTF-8, ce qui signifie que vous avez un caractère très illégal. Si
vous savez parfaitement ce que vous faites, vous pouvez inhiber cet
avertissement avec C<no warnings 'utf8';>.

#endif
=item Value of %s can be "0"; test with defined()

(La valeur de %s peut valoir « C<0> » ; testez avec C<defined()>) (W
misc) Dans une expression conditionnelle, vous avez utilisé C<<
<HANDLE> >>, C<< <*> >> (glob), C<each> ou C<readdir> en tant que
valeur booléenne. Chacune de ces constructions peut renvoyer une
valeur de « C<0> » ; cela rendrait fausse l'expression
conditionnelle, ce qui n'est probablement pas ce que vous désiriez.
Quand vous utilisez ces constructions dans des expressions
conditionnelles, testez leur valeur avec l'opérateur C<defined>. 

=item Value of CLI symbol "%s" too long

(La valeur du symbole de CLI « I<%s> » est trop longue) (W misc) Il
s'agit d'un avertissement spécifique à VMS. Perl a essayé de lire la
valeur d'un élément de C<%ENV> dans la table de symboles de CLI et a
trouvé une chaîne résultante plus longue que 1 024 caractères. La
valeur de retour a été tronquée à 1 024 caractères.

#if defined(perldiag560)
=item Variable "%s" is not imported %s

(La variable « I<%s> » n'est pas importée de I<%s>) (F) Alors que
C<use strict> est activé, vous vous êtes référés à une variable
globale qu'apparemment vous pensiez avoir importée depuis un autre
module car quelque chose d'autre ayant le même nom (habituellement un
sous-programme) est exporté par ce module. Cela veut habituellement
dire que vous vous êtes trompé de drôle de caractère (C<$>, C<@>,
C<%> ou C<&>) devant votre variable. 

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Variable "%s" is not imported%s

(La variable « I<%s> » n'a pas été importée) (F) Alors que C<use
strict> est en vigueur, vous avez fait référence à une variable globale
que, semble-t-il, vous pensiez avoir importé d'un autre module, parce
que quelque chose d'autre portant le même nom (habituellement un
sous-programme) est exporté par ce module. Le plus souvent, la
signification de ceci est que vous vous êtes trompé de drôle de
caractère au début de votre variable.

#endif
#if defined(perldiag580) or defined(perldiag573)
=item Variable length lookbehind not implemented in regex;

marked by <-- HERE in m/%s/

(La « rétrovision » (lookbehind) de longueur variable dans les
expressions rationnelles n'est pas implémentée) (F) Le test en
arrière, ou « rétro-vision » n'est autorisé que pour une
sous-expression dont la longueur est fixée et connue au moment de la
compilation. La mention « <-- HERE » indique l'endroit où le problème
a été constaté. Cf L<perlre>.

#endif
=item "%s" variable %s masks earlier declaration in same %s

(La variable « I<%s> » masque une déclaration précédente dans la même
I<%s>) (W misc) Une variable C<my> ou C<our> a été redéclarée dans la
portée ou dans l'instruction courante, éliminant effectivement tout
accès à l'instance précédente. Il s'agit presque toujours d'une erreur
de typographie. Remarquez que la variable déclarée plus tôt existera
toujours jusqu'à la fin de la portée ou jusqu'à ce que toutes les
fermetures qui s'y réfèrent soient détruites.

=item Variable "%s" may be unavailable

(La variable « I<%s> » peut être inaccessible) (W closure) Un
sous-programme I<anonyme> intérieur (imbriqué) se trouve dans un
sous-programme I<nommé> et encore à l'extérieur se trouve un autre
sous-programme ; et le sous-programme anonyme (le plus à l'intérieur)
fait référence à une variable lexicale définie dans le sous-programme
le plus à l'extérieur. Par exemple :

  sub le_plus_exterieur { my $a; sub au_milieu { sub { $a } } }

Si le sous-programme anonyme est appelé ou référencé (directement ou
indirectement) depuis le sous-programme le plus à l'extérieur, il va
partager la variable comme vous pouviez vous y attendre. Mais si le
sous-programme anonyme est appelé ou référencé lorsque le
sous-programme le plus à l'extérieur est inactif, il verra la valeur
de la variable partagée telle qu'elle était avant et pendant le
I<premier> appel au sous-programme le plus à l'extérieur, ce qui
n'est probablement pas ce que vous voulez.

Dans ces circonstances, il vaut habituellement mieux rendre anonyme
le sous-programme du milieu, en utilisant la syntaxe C<sub
{}>. Perl possède un support spécifique pour les variables partagées
dans les sous-programmes anonymes imbriqués ; un sous-programme nommé
entre les deux interfère avec cette fonctionnalité.

=item Variable syntax

(Syntaxe de variable) (A) Vous avez lancé accidentellement votre
script via I<csh> au lieu de Perl. Vérifiez la ligne C<#!> ou lancez
vous-même votre script manuellement dans Perl avec I<perl
nom_script>. 

=item Variable "%s" will not stay shared

(La variable « I<%s> » ne restera pas partagée) (W closure) Un
sous-programme I<nommé> intérieur (imbriqué) fait référence à une
variable lexicale définie dans un sous-programme extérieur.

Lorsque le sous-programme intérieur est appelé, il verra probablement
la valeur de la variable du sous-programme extérieur telle qu'elle
était avant et pendant le I<premier> appel au sous-programme
extérieur ; dans ce cas, après que le premier appel au sous-programme
extérieur est terminé, les sous-programmes intérieur et extérieur ne
partageront plus de valeur commune pour la variable. En d'autres
termes, la variable ne sera plus partagée.

De plus, si le sous-programme extérieur est anonyme et fait référence
à une variable lexicale en dehors de lui-même, alors les
sous-programmes intérieur et extérieur ne partageront I<jamais> la
variable donnée.

Le problème peut habituellement être résolu en rendant anonyme le
sous-programme intérieur, en utilisant la syntaxe C<sub {}>. Lorsque
des sous-programmes anonymes intérieurs, faisant référence à des
variables dans des sous-programmes extérieurs, sont appelés ou
référencés, ils sont automatiquement reliés à la valeur courante de
ces variables.

=item Version number must be a constant number

(Le numéro de version doit être un nombre constant) (P) La tentative
de conversion d'une instruction I<use Module n.n LISTE> vers le bloc
C<BEGIN> équivalent a trouvé une incohérence interne dans le numéro
de version. 

#if defined(perldiag580)
=item v-string in use/require is non-portable

(W portable) The use of v-strings is non-portable to older, pre-5.6, Perls.
If you want your scripts to be backward portable, use the floating
point version number: for example, instead of C<use 5.6.1> say
C<use 5.006_001>.  This of course won't help: the older Perls
won't suddenly start understanding newer features, but at least
they will show a sensible error message indicating the required
minimum version.

#endif
#if defined(perldiag573)
=item v-string in use/require is non-portable

(Les v-chaînes dans C<use> ou C<require> ne sont pas portables) (W)
L'utilisation des v-chaînes ne sont pas portables par rapport aux
versions de Perl antérieures à la 5.6. Si vous souhaitez que votre
script soit compatible avec les anciennes versions, utilisez les
versions sous forme de nombre à virgule flottable. Par exemple, au
lieu de C<use 5.6.1> écrivez C<use 5.006_001>. Bien sûr, cela ne va
pas vous aider beaucoup. Les anciennes versions de Perl ne vont pas
soudain se mettre à comprendre les nouvelles fonctionnalités, mais au
moins elles produiront un message d'erreur cohérent, indiquant la
version minimale de Perl pour fonctionner.

#endif
=item Warning: something's wrong

(Avertissement : quelque chose s'est mal passé) (W) Vous avez passé à
C<warn> une chaîne vide (l'équivalent d'un C<warn "">) ou vous l'avez
appelé sans arguments et C<$_> était vide. 

=item Warning: unable to close filehandle %s properly

(Avertissement : incapable de fermer proprement le handle de fichier
I<%s>) (S) Le C<close> implicite effectué par un C<open> a reçu une
indication d'erreur sur le C<close>. Cela indique habituellement que
votre système de fichier a épuisé l'espace disque disponible. 

=item Warning: Use of "%s" without parentheses is ambiguous

(Avertissement : L'utilisation de « I<%s> » sans parenthèses est
ambiguë) (S ambiguous) Vous avez écrit un opérateur unaire suivi par
quelque chose ressemblant à un opérateur binaire mais pouvant
également être interprété comme un terme ou un opérateur unaire. Par
exemple, si vous savez que la fonction C<rand> a un argument par
défaut valant C<1.0> et que vous écrivez :

  rand + 5;

vous pouvez I<penser> que vous avez écrit la même chose que :

  rand() + 5;

alors qu'en fait vous avez obtenu :

  rand(+5);

Donc mettez des parenthèses pour dire ce que vous voulez vraiment
dire.

#if defined(perldiag580) or defined(perldiag573)
=item Wide character in %s

(Caractère large dans I<%s>) 
(W utf8) Perl a rencontré un caractère large (>255) alors qu'il ne s'attendait
pas à en rencontrer. Par défaut, cet avertissement est actif pour les 
entrées / sorties (comme C<print>), mais il peut être inhibé par
C<no warnings 'utf8';>. Vous êtes supposé marquer le handle de fichier
avec un encodage, Cf. L<open> et L<perlfunc/binmode>.

#endif
=item write() on closed filehandle %s

(C<write()> sur un handle de fichier fermé) (W closed) Le handle de
fichier dans lequel vous écrivez s'est retrouvé fermé un moment
auparavant. Vérifiez le flux logique de votre programme. 

=item X outside of string

(C<X> en dehors d'une chaîne) (F) Vous aviez un canevas pour C<pack>
spécifiant une position relative avant le début de la chaîne en train
d'être dépaquetée. Cf. L<perlfunc/pack>.

=item x outside of string

(C<x> en dehors d'une chaîne) (F) Vous aviez un canevas pour C<pack>
spécifiant une position relative après la fin de la chaîne en train
d'être dépaquetée. Cf. L<perlfunc/pack>.

=item Xsub "%s" called in sort

(Xsub « I<%s> » appelé dans un C<sort>) (F) L'utilisation d'un
sous-programme externe pour la comparaison d'un C<sort> n'est pas
encore supportée. 

=item Xsub called in sort

(Xsub « I<%s> » appelé dans un C<sort>) (F) L'utilisation d'un
sous-programme externe pour la comparaison d'un C<sort> n'est pas
encore supportée. 

#if defined(perldiag560)
=item You can't use C<-l> on a filehandle

(Vous ne pouvez pas utiliser C<-l> sur un handle de fichier) (F) Un
handle de fichier représente un fichier ouvert et lorsque vous avez
ouvert le fichier, il avait déjà passé tous les liens symboliques que
vous essayez vraisemblablement de rechercher. Utilisez plutôt un nom
de fichier. 

#endif
=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!

(VOUS N'AVEZ TOUJOURS PAS DÉSACTIVÉ LES SCRIPTS SET-ID DANS LE NOYAU !) 
(F) Et vous ne le ferez probablement jamais car vous n'avez pas
les sources du noyau et probablement que votre fabriquant se moque
éperdument de ce que vous voulez. La meilleure solution est de mettre
une surcouche setuid en C autour de votre script en utilisant le
script I<wrapsuid> situé dans le répertoire C<eg> de la distribution
Perl. 

=item You need to quote "%s"

(Vous devez protéger « I<%s> » avec des guillemets ou des
apostrophes) (W syntax) Vous avez affecté un mot simple comme nom
d'un gestionnaire de signaux. Malheureusement, vous avez déjà un
sous-programme avec ce nom, ce qui veut dire que Perl 5 essayera
d'appeler ce sous-programme lorsque l'affectation sera exécutée, ce
qui n'est probablement pas ce que vous voulez. (Si I<c'est bien> ce
que vous voulez, mettez une I<&> devant.) 

=back

